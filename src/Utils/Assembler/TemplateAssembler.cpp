#include "TemplateAssembler.h"
#include "Utils\Debug\Debug.h"

#include <stdexcept>
#include <cstdlib>
#include <sstream>
#include <boost\filesystem\fstream.hpp>
#include <boost\scoped_array.hpp>

static const std::string INPUT_WILDCARD     = "<INPUT>";
static const uint8_t DELIMITER_INSTRUCTION  = 0x90;
static const size_t DELIMITER_BLOCK_SIZE    = 20;

TemplateAssembler::TemplateAssembler(const boost::filesystem::path& codePath, std::string assemblerName, std::string params)
    : m_codePath(codePath)
    , m_assemblerName(assemblerName)
    , m_params(params)
    , m_outputPath(codePath)
{
    m_outputPath.replace_extension("obj");
}

void TemplateAssembler::assemble()
{
    size_t inPos = m_params.find(INPUT_WILDCARD);
    if(inPos == std::string::npos)
        throw std::runtime_error(MODULE_NAME + " assembler parameters doesn't contain [" + INPUT_WILDCARD + "] wildcard");

    m_params.replace(inPos, INPUT_WILDCARD.size(), "\"" + m_codePath.string() + "\"");

    std::stringstream assembleCmd;
    assembleCmd << m_assemblerName << " " << m_params;

    LOG_INFO("Executing: [" + assembleCmd.str() + "]");
    if(system(assembleCmd.str().c_str()) != 0)
        throw std::runtime_error(MODULE_NAME + " assembling failed");
}

std::vector<uint8_t> TemplateAssembler::getUserCode()
{
    std::vector<uint8_t> userCode;

    size_t outputSize = static_cast<size_t>(boost::filesystem::file_size(m_outputPath));
    boost::scoped_array<uint8_t> objCode(new uint8_t[outputSize]);

    boost::filesystem::ifstream file;
    file.open(m_outputPath, std::ios::in | std::ios::binary);
    file.read(reinterpret_cast<char*>(objCode.get()), outputSize);
    file.close();

    size_t firstDelimiterBlockCounter = 0;
    size_t secondDelimiterBlockCounter = 0;
    unsigned int userCodeStartOffset;
    unsigned int userCodeEndOffset;
    bool codeFound = false;

    for(unsigned int i = 0; i < outputSize; ++i)
    {
        if(objCode[i] == DELIMITER_INSTRUCTION)
        {
            if(firstDelimiterBlockCounter != DELIMITER_BLOCK_SIZE)
            {
                ++firstDelimiterBlockCounter;
                if(firstDelimiterBlockCounter == DELIMITER_BLOCK_SIZE)
                    userCodeStartOffset = i + 1;
            }
            else
            {
                ++secondDelimiterBlockCounter;
                if(secondDelimiterBlockCounter == DELIMITER_BLOCK_SIZE)
                {
                    userCodeEndOffset = i + 1 - DELIMITER_BLOCK_SIZE;
                    codeFound = true;
                    break;
                }
            }
        }
        else
        {
            if(firstDelimiterBlockCounter != DELIMITER_BLOCK_SIZE)
                firstDelimiterBlockCounter = 0;
            else
                secondDelimiterBlockCounter = 0;
        }
    }

    if(!codeFound)
        throw std::runtime_error(MODULE_NAME + "user assembled code not found");

    unsigned int codeSize = userCodeEndOffset - userCodeStartOffset;
    userCode.resize(codeSize);
    std::memcpy(userCode.data(), objCode.get() + userCodeStartOffset, codeSize);

    return userCode;
}