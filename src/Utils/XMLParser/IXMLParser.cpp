#include "IXMLParser.h"
#include "Utils\Debug\Debug.h"

#include <boost\assign\list_of.hpp>

IXMLParser::IXMLParser(std::string derivedModuleName)
    : m_derivedModuleName(derivedModuleName)
{
    m_excludedStrings = boost::assign::list_of("<xmlattr>");
                                              ;
}

bool IXMLParser::findInRequiredSubnodes(std::string& nodeName, bool modify)
{
    std::vector<std::string>& requiredSubnodes = getRequiredSubnodes();
    for(std::string& requiredNode : requiredSubnodes)
    {
        if(requiredNode.find(nodeName) != std::string::npos)
        {
            // if fits '+' convention
            if(requiredNode.find("+") != std::string::npos && modify)
                nodeName = requiredNode;

            // if fits '*' convention
            if(requiredNode.find("*") != std::string::npos && modify)
                nodeName = requiredNode;

            return true;
        }
    }

    return false;
}

void IXMLParser::validateSubtree(const boost::property_tree::ptree& engineTree)
{
    std::vector<std::string> foundSubnodes;
    for(const boost::property_tree::ptree::value_type& node : engineTree)
    {
        std::string nodeName = node.first.data();
        if(nodeName == m_derivedModuleName)
            continue;

        if(std::find(m_excludedStrings.begin(), m_excludedStrings.end(), nodeName) != m_excludedStrings.end())
            continue;

        if(!findInRequiredSubnodes(nodeName, true))
        {
            std::stringstream errMsg;
            errMsg << MODULE_NAME + " module [" << m_derivedModuleName << "] does not require subnode [" << nodeName << "]";
            throw std::runtime_error(errMsg.str());
        }

        // if fits '*' convention, then we should save only one node name
        if(nodeName.find("*") != std::string::npos)
        {
            if(std::find(foundSubnodes.begin(), foundSubnodes.end(), nodeName) == foundSubnodes.end())
                foundSubnodes.push_back(nodeName);
        }
        else
            foundSubnodes.push_back(nodeName);
    }

    std::vector<std::string>& requiredSubnodes = getRequiredSubnodes();
    std::sort(requiredSubnodes.begin(), requiredSubnodes.end());
    std::sort(foundSubnodes.begin(), foundSubnodes.end());

    auto diff = std::mismatch(foundSubnodes.begin(), foundSubnodes.end(), requiredSubnodes.begin());
    if(foundSubnodes.size() != requiredSubnodes.size() || diff.first != foundSubnodes.end())
    {
        std::stringstream errMsg;
        errMsg << MODULE_NAME + " module [" << m_derivedModuleName << "] has invalid XML subtree";
        throw std::runtime_error(errMsg.str());
    }
}