#ifndef DEBUG_H
#define DEBUG_H

#include <iostream>
#include <iomanip>
#include <string>
#include <sstream>
#include <typeinfo>
#include <cassert>

enum LogLevel
{
    LOG_LEVEL_INFO,
    LOG_LEVEL_DEBUG,
    LOG_LEVEL_ERROR
};

/// @brief Macro showing variable in format 'viariable_name = viariable_value'
#define SHOW_VAR(x)     std::cout << "[DEBUG] " << #x << " = " << x << std::endl

/// @brief Macro showing hexadecimal variable in format 'viariable_name = viariable_value'
#define SHOW_HEX(x)     std::cout << "[DEBUG] " << #x << " = " << std::showbase << std::hex << x << std::endl; std::cout << std::dec

/// @brief Macro for printing empty line
#define LOG_EMPTY()     std::cout << std::endl

/// @brief Logging macros with different logging levels
#define LOG_INFO(x)     log(LOG_LEVEL_INFO, typeid(this).name(), x)
#define LOG_DEBUG(x)    log(LOG_LEVEL_DEBUG, typeid(this).name(), x)
#define LOG_ERROR(x)    log(LOG_LEVEL_ERROR, typeid(this).name(), x)

/// @brief Main logging function
/// @note Should not be used directly, use logging macros instead
void log(LogLevel level, std::string className, std::string msg);

/// @brief Macro for formatting class/module name to format '<class_name>'
#define MODULE_NAME     std::string("<") + moduleName(typeid(this).name()) + std::string(">")

/// @brief Function for obtaining class/module name
std::string moduleName(std::string className);

#endif