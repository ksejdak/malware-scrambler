#include "TemplateCodeProvider.h"
#include "Utils\Debug\Debug.h"

#include <stdexcept>
#include <cstdlib>
#include <sstream>
#include <fstream>
#include <boost\filesystem.hpp>
#include <boost\scoped_array.hpp>
#include <boost\algorithm\string.hpp>

static const std::string INPUT_WILDCARD     = "<INPUT>";
static const std::string OUTPUT_WILDCARD    = "<OUTPUT>";
static const uint8_t DELIMITER_INSTRUCTION  = 0x90;
static const size_t DELIMITER_BLOCK_SIZE    = 20;

// only for debugging purposes
static const bool REMOVE_BINARY_FILE        = true;

TemplateCodeProvider::TemplateCodeProvider(const boost::property_tree::ptree& codeProviderTree, std::string type)
    : ICodeProvider(codeProviderTree)
    , m_type(type)
{
    m_outputPath = m_inputPath;
    m_outputPath.replace_extension("obj");
}

void TemplateCodeProvider::generateMachineCode()
{
    // input wildcard replacement
    size_t inPos = m_params.find(INPUT_WILDCARD);
    if(inPos == std::string::npos)
        throw std::runtime_error(MODULE_NAME + " " + m_type + " parameters doesn't contain [" + INPUT_WILDCARD + "] wildcard");

    m_params.replace(inPos, INPUT_WILDCARD.size(), "\"" + m_processedInputPath.string() + "\"");

    // output wildcard replacement
    size_t outPos = m_params.find(OUTPUT_WILDCARD);
    if(outPos == std::string::npos)
        throw std::runtime_error(MODULE_NAME + " " + m_type + " parameters doesn't contain [" + OUTPUT_WILDCARD + "] wildcard");

    m_params.replace(outPos, OUTPUT_WILDCARD.size(), "\"" + m_outputPath.string() + "\"");

    std::stringstream providerCmd;
    providerCmd << m_appName << " " << m_params;

    LOG_INFO("Executing: [" + providerCmd.str() + "]");
    LOG_EMPTY();
    LOG_INFO("------------------------- START OF " + boost::to_upper_copy(m_type) + " OUTPUT -----------------------------");
    if(system(providerCmd.str().c_str()) != 0)
        throw std::runtime_error(MODULE_NAME + " generating failed");
    LOG_INFO("-------------------------- END OF " + boost::to_upper_copy(m_type) + " OUTPUT ------------------------------");
    LOG_EMPTY();

    copyGeneratedCode();
}

void TemplateCodeProvider::copyGeneratedCode()
{
    size_t outputSize = static_cast<size_t>(boost::filesystem::file_size(m_outputPath));
    boost::scoped_array<uint8_t> objCode(new uint8_t[outputSize]);

    std::ifstream file(m_outputPath.string(), std::ios::in | std::ios::binary);
    file.read(reinterpret_cast<char*>(objCode.get()), outputSize);
    file.close();

    size_t firstDelimiterBlockCounter = 0;
    size_t secondDelimiterBlockCounter = 0;
    unsigned int userCodeStartOffset;
    unsigned int userCodeEndOffset;
    bool codeFound = false;

    for(unsigned int i = 0; i < outputSize; ++i)
    {
        if(objCode[i] == DELIMITER_INSTRUCTION)
        {
            if(firstDelimiterBlockCounter != DELIMITER_BLOCK_SIZE)
            {
                ++firstDelimiterBlockCounter;
                if(firstDelimiterBlockCounter == DELIMITER_BLOCK_SIZE)
                    userCodeStartOffset = i + 1;
            }
            else
            {
                ++secondDelimiterBlockCounter;
                if(secondDelimiterBlockCounter == DELIMITER_BLOCK_SIZE)
                {
                    userCodeEndOffset = i + 1 - DELIMITER_BLOCK_SIZE;
                    codeFound = true;
                    break;
                }
            }
        }
        else
        {
            if(firstDelimiterBlockCounter != DELIMITER_BLOCK_SIZE)
                firstDelimiterBlockCounter = 0;
            else
                secondDelimiterBlockCounter = 0;
        }
    }

    if(!codeFound)
        throw std::runtime_error(MODULE_NAME + " user generated code not found");

    unsigned int codeSize = userCodeEndOffset - userCodeStartOffset;
    m_userCode.resize(codeSize);
    std::memcpy(m_userCode.data(), objCode.get() + userCodeStartOffset, codeSize);

    if(REMOVE_BINARY_FILE)
        boost::filesystem::remove(m_outputPath);
}