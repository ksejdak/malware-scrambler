#include "ICodeProvider.h"
#include "TemplateAssembler.h"
#include "TemplateCompiler.h"
#include "Utils\Debug\Debug.h"

#include <regex>
#include <boost\assign\list_of.hpp>
#include <boost\range\adaptors.hpp>

std::vector<const boost::property_tree::ptree> ICodeProvider::m_registeredCodeProviders;

std::shared_ptr<ICodeProvider> ICodeProvider::create(const boost::property_tree::ptree& codeProviderTree)
{
    m_registeredCodeProviders.push_back(codeProviderTree);

    std::string providerType = codeProviderTree.get<std::string>("<xmlattr>.type", "");
    if(providerType == "assembler")
        return std::shared_ptr<ICodeProvider>(new TemplateAssembler(codeProviderTree));

    if(providerType == "compiler")
        return std::shared_ptr<ICodeProvider>(new TemplateCompiler(codeProviderTree));

    throw std::runtime_error("CodeProvider does not define specific provider");
}

std::vector<const boost::property_tree::ptree>& ICodeProvider::getRegisteredCodeProviders()
{
    return m_registeredCodeProviders;
}

ICodeProvider::ICodeProvider(const boost::property_tree::ptree& codeProviderTree)
    : IXMLParser("CodeProvider")
    , m_isCompiled(false)
{
    validateSubtree(codeProviderTree);

    for(const boost::property_tree::ptree::value_type& node : codeProviderTree)
    {
        std::string nodeName = node.first.data();
        if(!findInRequiredSubnodes(nodeName))
            continue;

        if(nodeName == "Code")
            readCode(node.second);
        else if(nodeName == "Provider")
            readProvider(node.second);
    }
}

void ICodeProvider::addWildcard(std::string wildcard, std::string value)
{
    m_wildcards[wildcard] = value;
}

std::vector<uint8_t> ICodeProvider::getUserCode(bool emulateWildcards)
{
    if(!m_isCompiled)
    {
        if(emulateWildcards)
            replaceEmulatedWildcards();
        else
            replaceWildcards();

        generateMachineCode();
        boost::filesystem::remove(m_processedInputPath);
        m_isCompiled = true;
    }

    return m_userCode;
}

void ICodeProvider::readCode(const boost::property_tree::ptree& codeTree)
{
    m_inputPath = codeTree.get<std::string>("<xmlattr>.path", "");
    m_processedInputPath = m_inputPath.parent_path() / "processedCodeTemplate.asm";
}

void ICodeProvider::readProvider(const boost::property_tree::ptree& providerTree)
{
    m_appName = providerTree.get<std::string>("<xmlattr>.name", "");
    m_params = providerTree.get<std::string>("<xmlattr>.params", "");
}

void ICodeProvider::replaceWildcards()
{
    std::ifstream codeTemplateFile(m_inputPath.string());
    std::ofstream processedCodeTemplateFile(m_processedInputPath.string());
    std::string line;

    while(std::getline(codeTemplateFile, line))
    {
        for(std::string wildcard : m_wildcards | boost::adaptors::map_keys)
        {
            size_t wildcardPos = line.find(wildcard);
            if(wildcardPos != std::string::npos)
                line.replace(wildcardPos, wildcard.size(), m_wildcards[wildcard]);
        }

        processedCodeTemplateFile << line << std::endl;
    }

    codeTemplateFile.close();
    processedCodeTemplateFile.close();
}

void ICodeProvider::replaceEmulatedWildcards()
{
    std::ifstream codeTemplateFile(m_inputPath.string());
    std::ofstream processedCodeTemplateFile(m_processedInputPath.string());
    std::string line;

    while(std::getline(codeTemplateFile, line))
    {
        // replace <WILDCARD> with 0x0
        std::regex wildcardRegex("<*>");
        processedCodeTemplateFile << std::regex_replace(line, wildcardRegex, "0x0") << std::endl;
    }

    codeTemplateFile.close();
    processedCodeTemplateFile.close();
}

std::vector<std::string>& ICodeProvider::getRequiredSubnodes()
{
    static std::vector<std::string> requiredSubnodes = boost::assign::list_of("Code")
                                                                             ("Provider")
                                                                             ;
    return requiredSubnodes;
}