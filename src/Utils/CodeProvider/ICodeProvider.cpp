#include "ICodeProvider.h"
#include "TemplateCodeProvider.h"
#include "Utils\Debug\Debug.h"

#include <regex>
#include <boost\assign\list_of.hpp>
#include <boost\range\adaptors.hpp>

std::vector<const boost::property_tree::ptree> ICodeProvider::m_registeredCodeProviders;

std::shared_ptr<ICodeProvider> ICodeProvider::create(const boost::property_tree::ptree& codeProviderTree, bool registerProvider)
{
    if(registerProvider)
        m_registeredCodeProviders.push_back(codeProviderTree);

    std::string providerType = codeProviderTree.get<std::string>("<xmlattr>.type", "");
    if(providerType == "assembler" || providerType == "compiler")
        return std::shared_ptr<ICodeProvider>(new TemplateCodeProvider(codeProviderTree, providerType));

    throw std::runtime_error("CodeProvider does not define specific provider");
}

std::vector<const boost::property_tree::ptree>& ICodeProvider::getRegisteredCodeProviders()
{
    return m_registeredCodeProviders;
}

ICodeProvider::ICodeProvider(const boost::property_tree::ptree& codeProviderTree)
    : IXMLParser("CodeProvider")
    , m_isCompiled(false)
{
    validateSubtree(codeProviderTree);

    for(const boost::property_tree::ptree::value_type& node : codeProviderTree)
    {
        std::string nodeName = node.first.data();
        if(!findInRequiredSubnodes(nodeName))
            continue;

        if(nodeName == "Code")
            readCode(node.second);
        else if(nodeName == "Provider")
            readProvider(node.second);
    }
}

void ICodeProvider::addWildcard(std::string wildcard, std::string value)
{
    m_wildcards[wildcard] = value;
}

std::vector<uint8_t> ICodeProvider::getUserCode(bool emulateWildcards)
{
    if(!m_isCompiled)
    {
        if(emulateWildcards)
            replaceEmulatedWildcards();
        else
            replaceWildcards();

        generateMachineCode();
        boost::filesystem::remove(m_processedInputPath);
        m_isCompiled = true;
    }

    return m_userCode;
}

void ICodeProvider::readCode(const boost::property_tree::ptree& codeTree)
{
    m_inputPath = codeTree.get<std::string>("<xmlattr>.path", "");
    m_processedInputPath = m_inputPath.parent_path() / ("processedCodeTemplate" + m_inputPath.extension().string());
}

void ICodeProvider::readProvider(const boost::property_tree::ptree& providerTree)
{
    m_appName = providerTree.get<std::string>("<xmlattr>.name", "");
    m_params = providerTree.get<std::string>("<xmlattr>.params", "");
}

void ICodeProvider::replaceWildcards()
{
    std::ifstream codeTemplateFile(m_inputPath.string());
    std::ofstream processedCodeTemplateFile(m_processedInputPath.string());
    std::string line;

    while(std::getline(codeTemplateFile, line))
    {
        for(std::string wildcard : m_wildcards | boost::adaptors::map_keys)
        {
            size_t wildcardPos = line.find(wildcard);
            if(wildcardPos != std::string::npos)
                line.replace(wildcardPos, wildcard.size(), m_wildcards[wildcard]);
        }

        processedCodeTemplateFile << line << std::endl;
    }

    codeTemplateFile.close();
    processedCodeTemplateFile.close();
}

void ICodeProvider::replaceEmulatedWildcards()
{
    std::ifstream codeTemplateFile(m_inputPath.string());
    std::ofstream processedCodeTemplateFile(m_processedInputPath.string());
    std::string line;

    while(std::getline(codeTemplateFile, line))
    {
        // replace <WILDCARD> with 0x12345678
        std::regex wildcardRegex("<[A-Z_]*>");
        if(line.find("<DECODER_KEY>") != std::string::npos || line.find("<IMPORTS_SIZE>") != std::string::npos)
            // exception, because this value will be always byte-width
            processedCodeTemplateFile << std::regex_replace(line, wildcardRegex, "0x12") << std::endl;
        else
            processedCodeTemplateFile << std::regex_replace(line, wildcardRegex, "0x12345678") << std::endl;
    }

    codeTemplateFile.close();
    processedCodeTemplateFile.close();
}

std::vector<std::string>& ICodeProvider::getRequiredSubnodes()
{
    static std::vector<std::string> requiredSubnodes = boost::assign::list_of("Code")
                                                                             ("Provider")
                                                                             ;
    return requiredSubnodes;
}