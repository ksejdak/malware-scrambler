#include "MalwareScrambler.h"
#include "PortableExecutable\PortableExecutableCommon\PEFile.h"
#include "MutationEngine\MutationEngineCommon\MutationPipeline.h"
#include "MutationEngine\MutationEngineCommon\MutationPipelineFactory.h"
#include "Utils\Debug\Debug.h"
#include "Utils\Toolbox\Version.h"

#include <sstream>
#include <boost\filesystem.hpp>

MalwareScrambler::MalwareScrambler(const std::string& inputPath, const std::string& outputPath, const std::string& configPath)
    : m_inputPath(inputPath.c_str())
    , m_outputPath(outputPath.c_str())
    , m_configPath(configPath.c_str())
    , m_multipleFileProcessing(boost::filesystem::is_directory(m_inputPath))
    , m_mutatedFilesCount(0)
    , m_failedFilesCount(0)
{
}

void MalwareScrambler::run()
{
    LOG_INFO("Starting code-scrambler");

    if(m_multipleFileProcessing)
    {
        boost::filesystem::directory_iterator dirItEnd;
        for(boost::filesystem::directory_iterator dirIt(m_inputPath); dirIt != dirItEnd; ++dirIt)
        {
            if(!boost::filesystem::is_regular_file(dirIt->status()))
                continue;

            processOneFile(dirIt->path().string());
        }
    }
    else
        processOneFile(m_inputPath);

    printSummary();
}

std::string MalwareScrambler::getVersion()
{
    return PROGRAM_VERSION;
}

std::string MalwareScrambler::getAuthor()
{
    return PROGRAM_AUTHOR;
}

std::string MalwareScrambler::getBuildDate()
{
    return BUILD_TIME + " " + BUILD_DATE;
}

unsigned int MalwareScrambler::getMutatedFilesCount()
{
    return m_mutatedFilesCount;
}

unsigned int MalwareScrambler::getFailedFilesCount()
{
    return m_failedFilesCount;
}

void MalwareScrambler::processOneFile(const std::string& filePath)
{
    LOG_EMPTY();
    LOG_INFO("=========================================================================");
    LOG_INFO("Processing [file: " + filePath + "]");

    boost::filesystem::path currentPath = filePath;
    boost::filesystem::path outputPath = m_outputPath;
    outputPath /= "scrambled_" + currentPath.filename().string();

    try
    {
        std::shared_ptr<PEFile> PEFile(new PEFile(currentPath));
        std::shared_ptr<MutationPipeline> mutationPipeline = MutationPipelineFactory::getInstance().createPipeline(m_configPath);
        mutationPipeline->process(PEFile);
        PEFile->save(outputPath);
        ++m_mutatedFilesCount;
    }
    catch(std::exception& exc)
    {
        ++m_failedFilesCount;
        m_fileErrors[filePath] = exc.what();

        if(!m_multipleFileProcessing)
        {
            printSummary();
            std::exception_ptr excPtr = std::current_exception();
            std::rethrow_exception(excPtr);
        }

        std::stringstream ss;
        ss << "exception occured: [what: " << exc.what() << "], but multiple file processing, skipping";
        LOG_ERROR(ss.str());
    }
}

void MalwareScrambler::printSummary()
{
    LOG_EMPTY();
    LOG_INFO("===========================================================================");
    LOG_INFO("                                   SUMMARY                                 ");
    LOG_INFO("===========================================================================");
    LOG_INFO("Total files   : " + std::to_string(m_mutatedFilesCount + m_failedFilesCount));
    LOG_INFO("Mutated files : " + std::to_string(m_mutatedFilesCount)                     );
    LOG_INFO("Failed files  : " + std::to_string(m_failedFilesCount)                      );
    LOG_INFO("===========================================================================");
    if(m_failedFilesCount)
    {
        LOG_INFO("                                   ERRORS                                  ");
        LOG_INFO("===========================================================================");
        for(auto it = m_fileErrors.begin(); it != m_fileErrors.end(); ++it)
            LOG_INFO("[file: " + it->first + "] [error: " + it->second + "]"                  );
        LOG_INFO("===========================================================================");

    }
}