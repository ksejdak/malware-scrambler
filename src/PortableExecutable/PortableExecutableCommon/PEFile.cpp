#include "PEFile.h"
#include "Utils\Debug\Debug.h"
#include "Utils\Toolbox\Toolbox.h"

#include <stdexcept>
#include <iostream>
#include <iomanip>
#include <map>
#include <cstring>
#include <sstream>
#include <fstream>
#include <boost\range\adaptors.hpp>
#include <boost\assign.hpp>

static const bool DISABLE_UPX_ANALYSIS = false;

std::string machineCodeToString(unsigned int code)
{
    std::map<unsigned int, std::string> machineCodes = boost::assign::map_list_of(IMAGE_FILE_MACHINE_UNKNOWN,    "unknown")
                                                                                 (IMAGE_FILE_MACHINE_I386,       "Intel 386")
                                                                                 (IMAGE_FILE_MACHINE_R3000,      "MIPS little-endian")
                                                                                 (IMAGE_FILE_MACHINE_R4000,      "MIPS little-endian")
                                                                                 (IMAGE_FILE_MACHINE_R10000,     "MIPS little-endian")
                                                                                 (IMAGE_FILE_MACHINE_WCEMIPSV2,  "MIPS little-endian WCE v2")
                                                                                 (IMAGE_FILE_MACHINE_ALPHA,      "Alpha_AXP")
                                                                                 (IMAGE_FILE_MACHINE_SH3,        "SH3 little-endian")
                                                                                 (IMAGE_FILE_MACHINE_SH3DSP,     "SH3 DSP little-endian")
                                                                                 (IMAGE_FILE_MACHINE_SH3E,       "SH3E little-endian")
                                                                                 (IMAGE_FILE_MACHINE_SH4,        "SH4 little-endian")
                                                                                 (IMAGE_FILE_MACHINE_SH5,        "SH5")
                                                                                 (IMAGE_FILE_MACHINE_ARM,        "ARM Little-Endian")
                                                                                 (IMAGE_FILE_MACHINE_THUMB,      "ARM Thumb/Thumb-2 Little-Endian")
                                                                                 (IMAGE_FILE_MACHINE_ARMNT,      "ARM Thumb-2 Little-Endian")
                                                                                 (IMAGE_FILE_MACHINE_AM33,       "AM33")
                                                                                 (IMAGE_FILE_MACHINE_POWERPC,    "IBM PowerPC Little-Endian")
                                                                                 (IMAGE_FILE_MACHINE_POWERPCFP,  "IBM PowerPC FP Little-Endian")
                                                                                 (IMAGE_FILE_MACHINE_IA64,       "Intel 64")
                                                                                 (IMAGE_FILE_MACHINE_MIPS16,     "MIPS")
                                                                                 (IMAGE_FILE_MACHINE_ALPHA64,    "ALPHA64")
                                                                                 (IMAGE_FILE_MACHINE_MIPSFPU,    "MIPS")
                                                                                 (IMAGE_FILE_MACHINE_MIPSFPU16,  "MIPS")
                                                                                 (IMAGE_FILE_MACHINE_AXP64,      "ALPHA64")
                                                                                 (IMAGE_FILE_MACHINE_TRICORE,    "Infineon")
                                                                                 (IMAGE_FILE_MACHINE_CEF,        "CEF")
                                                                                 (IMAGE_FILE_MACHINE_EBC,        "EFI Byte Code")
                                                                                 (IMAGE_FILE_MACHINE_AMD64,      "AMD64 (K8)")
                                                                                 (IMAGE_FILE_MACHINE_M32R,       "M32R little-endian")
                                                                                 (IMAGE_FILE_MACHINE_CEE,        "CEE")
                                                                                 ;

    return machineCodes[code];
}

PEFile::PEFile(const boost::filesystem::path& filePath)
    : m_filePath(filePath)
    , m_fileSize(0)
    , m_isInitialized(false)
{
    m_DOSHeader.reset(new IMAGE_DOS_HEADER);
    m_NTHeaders.reset(new IMAGE_NT_HEADERS);

    init();
}

std::shared_ptr<IMAGE_DOS_HEADER> PEFile::getDOSHeader()
{
    throwIfNotInitialized();
    return m_DOSHeader;
}

std::shared_ptr<IMAGE_NT_HEADERS> PEFile::getNTHeaders()
{
    throwIfNotInitialized();
    return m_NTHeaders;
}

std::vector<std::string>& PEFile::getSectionsOrder()
{
    throwIfNotInitialized();
    return m_sectionsOrder;
}

std::map<std::string, std::shared_ptr<PESection>>& PEFile::getSections()
{
    throwIfNotInitialized();
    return m_sections;
}

std::shared_ptr<DataDirectory> PEFile::getDataDirectory()
{
    return m_dataDirectory;
}

bool PEFile::isX86()
{
    return m_NTHeaders->FileHeader.Machine == IMAGE_FILE_MACHINE_I386;
}

void PEFile::setFileSize(size_t fileSize)
{
    m_fileSize = fileSize;
}

void PEFile::save(const boost::filesystem::path& filePath)
{
    LOG_EMPTY();
    throwIfNotInitialized();
    boost::filesystem::path savePath = (filePath == "") ? m_filePath : filePath;

    std::stringstream debugFilenameMsg;
    debugFilenameMsg << "Saving file to [savePath: " << savePath << "]" << std::endl;
    LOG_DEBUG(debugFilenameMsg.str());

    // create file and resize
    std::ofstream file(savePath.string(), std::ios::out | std::ios::binary);
    for(unsigned int i = 0; i < m_fileSize; ++i)
        file.write("\0", 1);
    file.seekp(0, std::ios::beg);
    
    // DOS header
    file.write(reinterpret_cast<char*>(m_DOSHeader.get()), sizeof(IMAGE_DOS_HEADER));

    // DOS stub
    size_t DOSStubSize = m_DOSHeader->e_lfanew - sizeof(IMAGE_DOS_HEADER);
    file.write(reinterpret_cast<char*>(m_DOSStub.get()), DOSStubSize);

    // NT headers
    file.write(reinterpret_cast<char*>(m_NTHeaders.get()), sizeof(IMAGE_NT_HEADERS));

    // section headers
    for(std::string sectionName : m_sectionsOrder)
    {
        std::shared_ptr<IMAGE_SECTION_HEADER> sectionHeader = m_sections[sectionName]->getSectionHeader();
        file.write(reinterpret_cast<char*>(sectionHeader.get()), sizeof(IMAGE_SECTION_HEADER));
    }

    // copy bound IAT area (if present). This should be done, because usually (or always) bound IAT is outside any section. In this case virtual address is equal to file offset
    size_t boundIATOffset = m_NTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress;
    size_t boundIATSize = m_NTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size;
    if(boundIATSize)
    {
        file.seekp(boundIATOffset);
        file.write(reinterpret_cast<char*>(m_boundIAT.get()), boundIATSize);
    }

    // sections
    for(std::string sectionName : m_sectionsOrder)
    {
        std::shared_ptr<PESection> section = m_sections[sectionName];

        std::stringstream debugMsg;
        debugMsg << "Saving section - "
                 << "[name: "         << std::setw(7) << std::left << section->getName()                                                         << "] "
                 << "[virtual size: " << std::setw(7) << std::left << std::showbase << std::hex << section->getVirtualSize()                     << "] "
                 << "[raw size: "     << std::setw(7) << std::left << std::showbase << std::hex << section->getRawSize()                         << "] "
                 << "[offset: "       << std::setw(7) << std::left << std::showbase << std::hex << section->getSectionHeader()->PointerToRawData << "] "
                 << "[RVA: "          << std::setw(7) << std::left << std::showbase << std::hex << section->getSectionHeader()->VirtualAddress   << "]";
        LOG_DEBUG(debugMsg.str());

        section->save(file);
    }

    file.close();
}

void PEFile::init()
{
    LOG_EMPTY();
    if(!boost::filesystem::exists(m_filePath))
    {
        std::stringstream errMsg;
        errMsg << MODULE_NAME + " file \"" << m_filePath.string() << "\" does not exist";
        throw std::runtime_error(errMsg.str());
    }

    m_fileSize = static_cast<size_t>(boost::filesystem::file_size(m_filePath));
    boost::shared_array<uint8_t> image(new uint8_t[m_fileSize]);

    std::ifstream file(m_filePath.string(), std::ios::in | std::ios::binary);
    file.read(reinterpret_cast<char*>(image.get()), m_fileSize);
    file.close();

    std::memcpy(m_DOSHeader.get(), image.get(), sizeof(IMAGE_DOS_HEADER));
    size_t DOSStubSize = m_DOSHeader->e_lfanew - sizeof(IMAGE_DOS_HEADER);
    m_DOSStub.reset(new uint8_t[DOSStubSize]);
    std::memcpy(m_DOSStub.get(), image.get() + sizeof(IMAGE_DOS_HEADER), DOSStubSize);
    std::memcpy(m_NTHeaders.get(), image.get() + m_DOSHeader->e_lfanew, sizeof(IMAGE_NT_HEADERS));

    // check if MZ
    if(m_DOSHeader->e_magic != IMAGE_DOS_SIGNATURE)
        throw std::runtime_error(MODULE_NAME + " MZ signature not found");

    // check if PE00
    if(m_NTHeaders->Signature != IMAGE_NT_SIGNATURE)
        throw std::runtime_error(MODULE_NAME + " PE signature not found");

    // check if x86, other architectures are not supported
    if(!isX86())
    {
        std::stringstream errMsg;
        errMsg << MODULE_NAME + " unsupported processor architecture [type: " << machineCodeToString(m_NTHeaders->FileHeader.Machine) << "]";
        throw std::runtime_error(errMsg.str());
    }

    // copy bound IAT area (if present). This should be done, because usually (or always) bound IAT is outside any section. In this case virtual address is equal to file offset
    size_t boundIATOffset = m_NTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress;
    size_t boundIATSize = m_NTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size;
    if(boundIATSize)
    {
        m_boundIAT.reset(new uint8_t[boundIATSize]);
        std::memcpy(m_boundIAT.get(), image.get() + boundIATOffset, boundIATSize);
    }

    // initialize sections and their headers
    DWORD firstSectionHeaderOffset = m_DOSHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS);
    unsigned int sectionNum = m_NTHeaders->FileHeader.NumberOfSections;
    for(unsigned int i = 0; i < sectionNum; ++i)
    {
        // section header
        uint8_t* sectionHeaderAddress = image.get() + firstSectionHeaderOffset + i * sizeof(IMAGE_SECTION_HEADER);

        std::shared_ptr<IMAGE_SECTION_HEADER> sectionHeader(new IMAGE_SECTION_HEADER);
        std::memcpy(sectionHeader.get(), sectionHeaderAddress, sizeof(IMAGE_SECTION_HEADER));

        // section
        std::shared_ptr<PESection> section(new PESection(sectionHeader, image));
        if(section->getName().find("UPX") != std::string::npos && DISABLE_UPX_ANALYSIS)
            throw std::runtime_error(MODULE_NAME + " file seems to be packed with UPX");

        m_sections[section->getName()] = section;
        m_sectionsOrder.push_back(section->getName());

        std::stringstream debugMsg;
        debugMsg << "Found section header - "
                 << "[name: "         << std::setw(7) << std::left << section->getName()                                                         << "] "
                 << "[virtual size: " << std::setw(7) << std::left << std::showbase << std::hex << section->getVirtualSize()                     << "] "
                 << "[raw size: "     << std::setw(7) << std::left << std::showbase << std::hex << section->getRawSize()                         << "] "
                 << "[offset: "       << std::setw(7) << std::left << std::showbase << std::hex << section->getSectionHeader()->PointerToRawData << "] "
                 << "[RVA: "          << std::setw(7) << std::left << std::showbase << std::hex << sectionHeader->VirtualAddress                 << "]";
        LOG_DEBUG(debugMsg.str());
    }

    m_dataDirectory.reset(new DataDirectory(m_NTHeaders->OptionalHeader.DataDirectory, this));
    m_isInitialized = true;
}

unsigned long PEFile::RVAToOffset(unsigned long RVA)
{
    std::shared_ptr<IMAGE_SECTION_HEADER> sectionHeader = RVAToSectionHeader(RVA);

    return RVA + sectionHeader->PointerToRawData - sectionHeader->VirtualAddress;
}

std::shared_ptr<PESection> PEFile::RVAToSection(unsigned long RVA)
{
    std::shared_ptr<IMAGE_SECTION_HEADER> sectionHeader = RVAToSectionHeader(RVA);
    std::string sectionName = (char *) sectionHeader->Name;
    if(sectionName == "")
        sectionName = Toolbox::uniqueAnonymousSectionName(sectionHeader->VirtualAddress);

    return m_sections[sectionName];
}

unsigned long PEFile::offsetToRVA(unsigned long offset)
{
    std::shared_ptr<IMAGE_SECTION_HEADER> sectionHeader = offsetToSectionHeader(offset);

    return offset + sectionHeader->VirtualAddress - sectionHeader->PointerToRawData;
}

std::shared_ptr<PESection> PEFile::offsetToSection(unsigned long offset)
{
    std::shared_ptr<IMAGE_SECTION_HEADER> sectionHeader = offsetToSectionHeader(offset);
    std::string sectionName = (char *) sectionHeader->Name;

    return m_sections[sectionName];
}

std::shared_ptr<IMAGE_SECTION_HEADER> PEFile::RVAToSectionHeader(unsigned long RVA)
{
    for(std::shared_ptr<PESection> section : m_sections | boost::adaptors::map_values)
    {
        unsigned long sectionStartRVA = section->getSectionHeader()->VirtualAddress;
        unsigned long sectionEndRVA = sectionStartRVA + section->getSectionHeader()->Misc.VirtualSize;
        if(RVA >= sectionStartRVA && RVA < sectionEndRVA)
            return section->getSectionHeader();
    }

    throw std::runtime_error(MODULE_NAME + " RVA not in scope of any section");
}

std::shared_ptr<IMAGE_SECTION_HEADER> PEFile::offsetToSectionHeader(unsigned long offset)
{
    for(std::shared_ptr<PESection> section : m_sections | boost::adaptors::map_values)
    {
        unsigned long sectionStartOffset = section->getSectionHeader()->PointerToRawData;
        unsigned long sectionEndOffset = sectionStartOffset + section->getSectionHeader()->SizeOfRawData;
        if(offset >= sectionStartOffset && offset < sectionEndOffset)
            return section->getSectionHeader();
    }

    throw std::runtime_error(MODULE_NAME + " offset not in scope of any section");
}

void PEFile::throwIfNotInitialized()
{
    if(!m_isInitialized)
        throw std::runtime_error(MODULE_NAME + " PEFile not initialized");
}