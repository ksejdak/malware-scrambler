#include "PESection.h"
#include "Utils\Debug\Debug.h"

#include <sstream>
#include <cstring>

PESection::PESection(std::shared_ptr<IMAGE_SECTION_HEADER> sectionHeader, boost::shared_array<uint8_t> image, SectionType sectionType)
    : m_sectionHeader(sectionHeader)
    , m_sectionType(sectionType)
    , m_isShrinked(false)
{
    // copy whole raw section data
    m_data.reset(new std::vector<uint8_t>(getRawSize()));
    std::memcpy(m_data->data(), image.get() + sectionHeader->PointerToRawData, getRawSize());

    // shrink data (remove alignment padding) if virtual size is smaller than raw size
    if(getVirtualSize() < getRawSize())
    {
        m_data->resize(getVirtualSize());
        m_isShrinked = true;
    }
}

std::string PESection::getName()
{
    return reinterpret_cast<char*>(m_sectionHeader->Name);
}

size_t PESection::getDataSize()
{
    return m_data->size();
}

size_t PESection::getRawSize()
{
    return static_cast<size_t>(m_sectionHeader->SizeOfRawData);
}

size_t PESection::getVirtualSize()
{
    return static_cast<size_t>(m_sectionHeader->Misc.VirtualSize);
}

SectionType PESection::getSectionType()
{
    return m_sectionType;
}

bool PESection::isShrinked()
{
    return m_isShrinked;
}

std::shared_ptr<std::vector<uint8_t>> PESection::getData()
{
    return m_data;
}

std::shared_ptr<IMAGE_SECTION_HEADER> PESection::getSectionHeader()
{
    if(!m_sectionHeader)
        generateSectionHeader();

    return m_sectionHeader;
}

void PESection::setName(std::string name)
{
    size_t n = name.copy(reinterpret_cast<char*>(m_sectionHeader->Name), IMAGE_SIZEOF_SHORT_NAME - 1);
    m_sectionHeader->Name[n] = '\0';
}

void PESection::setRawSize(unsigned long rawSize)
{
    m_sectionHeader->SizeOfRawData = rawSize;
}

void PESection::setVirtualSize(unsigned long virtualSize)
{
    m_sectionHeader->Misc.VirtualSize = virtualSize;
}

void PESection::setSectionType(SectionType sectionType)
{
    m_sectionType = sectionType;
}

void PESection::setData(std::shared_ptr<std::vector<uint8_t>> data)
{
    m_data = data;
}

void PESection::setSectionHeader(std::shared_ptr<IMAGE_SECTION_HEADER> sectionHeader)
{
    m_sectionHeader = sectionHeader;
}

void PESection::save(std::ofstream& file)
{
    if(getRawSize() == 0)
    {
        LOG_EMPTY();
        std::stringstream debugEmptySection;
        debugEmptySection << "Empty section [raw size: " << getRawSize() << "] - skipping";
        LOG_DEBUG(debugEmptySection.str());
        LOG_EMPTY();
        return;
    }

    file.seekp(static_cast<size_t>(m_sectionHeader->PointerToRawData));
    size_t saveSize = (getVirtualSize() < getRawSize()) ? getVirtualSize() : getRawSize();
    file.write(reinterpret_cast<char*>(m_data->data()), saveSize);
}

void PESection::generateSectionHeader()
{
    m_sectionHeader.reset(new IMAGE_SECTION_HEADER);
}