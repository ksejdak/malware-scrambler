#ifndef RESOURCESSECTION_H
#define RESOURCESSECTION_H

#include "PortableExecutable\PortableExecutableCommon\PESection.h"
#include "ResourcesStructures.h"
#include "ResourceDirectory.h"

class ResourcesSection : public PESection
{
public:
    /// @brief Constructor with ready section header
    /// @param [in] sectionHeader       section header
    /// @param [in] image               image data
    /// @param [in] sectionType         type of section
    ResourcesSection(std::shared_ptr<IMAGE_SECTION_HEADER> sectionHeader, boost::shared_array<uint8_t> image, SectionType sectionType);

    /// @brief Virtual destructor
    virtual ~ResourcesSection() {}

    /// @brief Adds new resource to PE file
    /// @note  Adding resource may have impact on starting offset of all following sections
    /// @param [in] newResource         new resource structure
    /// @return additional size that has to be added to resource section
    size_t addNewResource(std::shared_ptr<NewResource> newResource);

    /// @brief Returns resources section root directory
    /// @return pointer to root directory
    std::shared_ptr<ResourceDirectory> getRoot();

    /// @brief Saves section to file
    /// @note  Function takes care about file alignment
    /// @param [in] file                output file stream
    virtual void save(boost::filesystem::ofstream& file);

private:
    /// @brief Adds child entries for given directory component and its directory entry
    /// @param [in] parentComponent     pointer to parent component where childs will be added
    /// @param [in] entry               resource directory entry describing given entry
    /// @note  When called for the first time, we don't know what is the entry for root. We assume that first data in .rsrc section
    ///        is PIMAGE_RESOURCE_DIRECTORY.
    void addDirectoryEntries(std::shared_ptr<ResourceDirectory> parentComponent, PIMAGE_RESOURCE_DIRECTORY_ENTRY entry = NULL);

    std::shared_ptr<ResourceDirectory> m_root;
};

#endif