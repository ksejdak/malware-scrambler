#include "ResourceDirectory.h"
#include "ResourceEntry.h"
#include "Utils\Debug\Debug.h"

ResourceDirectory::ResourceDirectory(PESection* section, PIMAGE_RESOURCE_DIRECTORY_ENTRY entry)
    : IResourceComponent(section, entry)
{
    m_isRoot = entry ? false : true;
    m_entry.NameIsString = 0;
}

bool ResourceDirectory::isDirectory()
{
    return true;
}

unsigned int ResourceDirectory::getNamedResourcesCount()
{
    unsigned int namedResourcesCount = 0;
    for(std::shared_ptr<IResourceComponent> child : m_entries)
    {
        if(child->isNamed())
            ++namedResourcesCount;
    }

    return namedResourcesCount;
}

unsigned int ResourceDirectory::getIdResourcesCount()
{
    unsigned int idResourcesCount = 0;
    for(std::shared_ptr<IResourceComponent> child : m_entries)
    {
        if(!child->isNamed())
            ++idResourcesCount;
    }

    return idResourcesCount;
}

void ResourceDirectory::add(std::shared_ptr<IResourceComponent> entry)
{
    m_entries.push_back(entry);
}

size_t ResourceDirectory::save(boost::filesystem::ofstream& file, size_t saveOffset)
{
    size_t entryEndPos = 0;
    if(!m_isRoot)
    {
        // directory entry
        size_t dirEntryBegOffset = static_cast<size_t>(file.tellp());
        size_t dirEntryEndOffset = dirEntryBegOffset + sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY);
        m_entry.OffsetToDirectory = dirEntryEndOffset + saveOffset - m_sectionOffset;

        file.write(reinterpret_cast<char*>(&m_entry), sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY));

        // save file position to rewind later
        entryEndPos = static_cast<size_t>(file.tellp());

        // set position to directory offset
        file.seekp(dirEntryEndOffset + saveOffset);
    }

    IMAGE_RESOURCE_DIRECTORY directory;
    std::memset(&directory, 0, sizeof(IMAGE_RESOURCE_DIRECTORY));
    directory.NumberOfIdEntries = getIdResourcesCount();
    directory.NumberOfNamedEntries = getNamedResourcesCount();
    file.write(reinterpret_cast<char*>(&directory), sizeof(IMAGE_RESOURCE_DIRECTORY));

    size_t childSaveOffset = (m_entries.size() - 1) * sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY);
    for(unsigned int i = 0; i < m_entries.size(); ++i)
        childSaveOffset = m_entries[i]->save(file, childSaveOffset);

    if(!m_isRoot)
        file.seekp(entryEndPos);

    size_t nextSaveOffset = childSaveOffset + sizeof(IMAGE_RESOURCE_DIRECTORY_ENTRY) + sizeof(IMAGE_RESOURCE_DIRECTORY);
    return nextSaveOffset;
}

void ResourceDirectory::debugPrint(int indentation)
{
    std::stringstream ss;
    ss << std::string(indentation, '\t') << "<DIR> " << getComponentName();
    LOG_DEBUG(ss.str());

    int entriesIndentation = indentation + 1;
    for(std::shared_ptr<IResourceComponent> child : m_entries)
        child->debugPrint(entriesIndentation);
}

ResourceIterator::ResourceIterator(std::shared_ptr<ResourceDirectory> begin)
    : m_begin(begin)
    , m_currentParent(begin)
{
    m_currentChildNumStack.push_back(-1);
}

std::shared_ptr<ResourceEntry> ResourceIterator::getNext()
{
    m_currentChildNumStack.front() += 1;
    int currentChildNum = m_currentChildNumStack.front();

    while(currentChildNum == m_currentParent->m_entries.size())
    {
        if(m_currentParent == m_begin)
        {
            m_currentResource.reset();
            return m_currentResource;
        }

        m_currentParent = std::static_pointer_cast<ResourceDirectory>(m_currentParent->m_parentComponent);
        m_currentChildNumStack.pop_front();
        m_currentChildNumStack.front() += 1;
        currentChildNum = m_currentChildNumStack.front();
    }

    while(m_currentParent->m_entries[currentChildNum]->isDirectory())
    {
        m_currentChildNumStack.push_front(0);
        m_currentParent = std::static_pointer_cast<ResourceDirectory>(m_currentParent->m_entries[currentChildNum]);
        currentChildNum = m_currentChildNumStack.front();
    }
    
    m_currentResource = std::static_pointer_cast<ResourceEntry>(m_currentParent->m_entries[currentChildNum]);
    return m_currentResource;
}

bool ResourceIterator::remove()
{
    if(!m_currentResource)
        return false;

    while(m_currentParent->m_entries.size() == 1)
    {
        m_currentParent = m_currentParent->m_parentComponent;
        m_currentChildNumStack.pop_front();
    }

    m_currentParent->m_entries.erase(m_currentParent->m_entries.begin() + m_currentChildNumStack.front());
    return true;
}