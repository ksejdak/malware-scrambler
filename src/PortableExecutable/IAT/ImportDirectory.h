#ifndef IMPORTDIRECTORY_H
#define IMPORTDIRECTORY_H

#include "PortableExecutable\PortableExecutableCommon\DataDirectory.h"
#include "PortableExecutable\PortableExecutableCommon\PEFile.h"

#include <vector>
#include <map>
#include <string>

class ImportDirectory : public DataDirectoryEntry
{
public:
    /// @brief Constructor
    /// @param [in] dataDirectoryEntry      entry from data directory
    /// @param [in] PE                      pointer to PE file that holds this data directory
    ImportDirectory(PIMAGE_DATA_DIRECTORY dataDirectoryEntry, PEFile* PE);

    /// @brief Virtual destructor
    virtual ~ImportDirectory() {}

    /// @see DataDirectoryEntry::addToRVAs
    virtual void addToRVAs(size_t value);

private:
    /// @brief Retrieves imported DLL name
    /// @param [in] importDescriptor        import descriptor to be checked
    /// @return imported DLL name 
    std::string getImportedDLLName(PIMAGE_IMPORT_DESCRIPTOR importDescriptor);

    /// @brief Retrieves imported function names and saves in internal map
    /// @param [in] importDescriptor        import descriptor to be checked
    void saveImportedFunctionNames(PIMAGE_IMPORT_DESCRIPTOR importDescriptor);

    /// @brief Checks if given import descriptor is empty
    /// @param [in] importDescriptor        import descriptor to be checked
    /// @return true if empty, false otherwise
    bool isDescriptorEmpty(PIMAGE_IMPORT_DESCRIPTOR importDescriptor);

    /// @brief Checks if given thunkdata is empty
    /// @param [in] thunkData              thunk data to be checked
    /// @return true if empty, false otherwise
    bool isThunkDataEmpty(PIMAGE_THUNK_DATA thunkData);

private:
    struct ImportedFunction
    {
        bool isNamed;
        const char* name;
        unsigned int ordinal;
        unsigned int hint;
    };

    std::vector<PIMAGE_IMPORT_DESCRIPTOR> m_importDescriptors;
    std::map<std::string, std::vector<ImportedFunction>> m_importedFunctions;
};

#endif