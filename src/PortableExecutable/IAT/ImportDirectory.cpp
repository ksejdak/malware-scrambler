#include "ImportDirectory.h"
#include "Utils\Debug\Debug.h"

#include <cstring>
#include <sstream>
#include <string>
#include <boost\scoped_array.hpp>

ImportDirectory::ImportDirectory(PIMAGE_DATA_DIRECTORY dataDirectoryEntry, PEFile* PE)
    : DataDirectoryEntry(dataDirectoryEntry, PE)
{
    LOG_EMPTY();
    LOG_INFO("Import directory:");

    uint8_t* importDescriptorsPtr = getDataForRVA(m_entryRVA);

    int foundDLLsCount = 0;

    while(true)
    {
        assert(sizeof(IMAGE_IMPORT_DESCRIPTOR) * foundDLLsCount <= m_entryVirtualSize);

        PIMAGE_IMPORT_DESCRIPTOR importDescriptor = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(importDescriptorsPtr + foundDLLsCount * sizeof(IMAGE_IMPORT_DESCRIPTOR));
        if(isDescriptorEmpty(importDescriptor))
            break;

        saveImportedFunctionNames(importDescriptor);

        m_importDescriptors.push_back(importDescriptor);
        ++foundDLLsCount;
    }

    std::stringstream msg;
    for(auto dllIt = m_importedFunctions.begin(); dllIt != m_importedFunctions.end(); ++dllIt)
    {
        msg << "Importing [DLL: " << dllIt->first << "]:" << std::endl;
        for(ImportedFunction function : dllIt->second)
        {
            msg << "\t ";
            if(function.isNamed)
            {
                msg << "[function: " << std::setw(25) << std::left << function.name << "] "
                    << "[hint: "     << std::setw(5)  << std::left << std::dec << ((function.hint == 0) ? "-" : std::to_string(function.hint)) << "]" << std::endl;
            }
            else
                msg << "[ordinal: "  << std::setw(5)  << std::left << std::dec << function.ordinal << "]" << std::endl;
        }
        msg << std::endl;
    }

    LOG_INFO(msg.str());
    LOG_EMPTY();
}

void ImportDirectory::addToRVAs(size_t value)
{
    for(PIMAGE_IMPORT_DESCRIPTOR importDescriptor : m_importDescriptors)
    {
        importDescriptor->Name += value;
        importDescriptor->FirstThunk += value;
        importDescriptor->OriginalFirstThunk += value;

        uint8_t* ptrINT = getDataForRVA(importDescriptor->OriginalFirstThunk);
        uint8_t* ptrIAT = getDataForRVA(importDescriptor->FirstThunk);

        int foundFunctionsCount = 0;
        while(true)
        {
            PIMAGE_THUNK_DATA entryINT = reinterpret_cast<PIMAGE_THUNK_DATA>(ptrINT + foundFunctionsCount * sizeof(IMAGE_THUNK_DATA));
            PIMAGE_THUNK_DATA entryIAT = reinterpret_cast<PIMAGE_THUNK_DATA>(ptrIAT + foundFunctionsCount * sizeof(IMAGE_THUNK_DATA));
            if(isThunkDataEmpty(entryINT))
                break;

            try
            {
                // this may throw exception, if not RVA
                getDataForRVA(entryINT->u1.AddressOfData);
                entryINT->u1.AddressOfData += value;
                entryIAT->u1.AddressOfData += value;
            }
            catch(const std::exception&)
            {
                // pass through
            }
            ++foundFunctionsCount;
        }
    }
}

std::string ImportDirectory::getImportedDLLName(PIMAGE_IMPORT_DESCRIPTOR importDescriptor)
{
    uint8_t* dllNamePtr = getDataForRVA(importDescriptor->Name);
    std::string dllName = reinterpret_cast<const char*>(dllNamePtr);

    return dllName;
}

void ImportDirectory::saveImportedFunctionNames(PIMAGE_IMPORT_DESCRIPTOR importDescriptor)
{
    std::vector<ImportedFunction> importedFunctions;
    uint8_t* ptrINT = getDataForRVA(importDescriptor->OriginalFirstThunk);

    int foundFunctionsCount = 0;

    while(true)
    {
        PIMAGE_THUNK_DATA entryINT = reinterpret_cast<PIMAGE_THUNK_DATA>(ptrINT + foundFunctionsCount * sizeof(IMAGE_THUNK_DATA));
        if(isThunkDataEmpty(entryINT))
            break;

        ImportedFunction importedFunction = { 0 };
        try
        {
            uint8_t* importNamePtr = getDataForRVA(entryINT->u1.AddressOfData);
            PIMAGE_IMPORT_BY_NAME importName = reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(importNamePtr);
            importedFunction.isNamed = true;
            importedFunction.ordinal = 0;
            importedFunction.name = importName->Name;
            importedFunction.hint = importName->Hint;
        }
        catch(const std::exception&)
        {
            importedFunction.isNamed = false;
            importedFunction.ordinal = entryINT->u1.Ordinal;
            importedFunction.name = nullptr;
            importedFunction.hint = 0;
        }
        
        importedFunctions.push_back(importedFunction);
        ++foundFunctionsCount;
    }

    std::string dllName = getImportedDLLName(importDescriptor);
    m_importedFunctions[dllName] = importedFunctions;
}

bool ImportDirectory::isDescriptorEmpty(PIMAGE_IMPORT_DESCRIPTOR importDescriptor)
{
    boost::scoped_array<uint8_t> zeroBlock(new uint8_t[sizeof(IMAGE_IMPORT_DESCRIPTOR)]);
    std::memset(zeroBlock.get(), 0, sizeof(IMAGE_IMPORT_DESCRIPTOR));
    int diff = std::memcmp(importDescriptor, zeroBlock.get(), sizeof(IMAGE_IMPORT_DESCRIPTOR));
    bool isEmpty = (diff == 0) ? true : false;

    return isEmpty;
}

bool ImportDirectory::isThunkDataEmpty(PIMAGE_THUNK_DATA thunkData)
{
    bool isEmpty = (thunkData->u1.AddressOfData == 0) ? true : false;

    return isEmpty;
}