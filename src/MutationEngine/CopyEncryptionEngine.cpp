#include "CopyEncryptionEngine.h"
#include "PortableExecutable\PortableExecutableCommon\CodeSectionLayoutAnalyzer.h"
#include "Utils\Debug\Debug.h"

#include <sstream>
#include <boost\assign\list_of.hpp>

static const std::string IS_LAST_WILDCARD               = "<IS_LAST>";
static const std::string DECODER_KEY_WILDCARD           = "<DECODER_KEY>";
static const std::string SPARED_CODE_SIZE_WILDCARD      = "<SPARED_CODE_SIZE>";
static const std::string OFFSET_TO_EXILED_CODE_WILDCARD = "<OFFSET_TO_EXILED_CODE>";
static const std::string EXILED_CODE_SIZE_WILDCARD      = "<EXILED_CODE_SIZE>";
static const std::string OFFSET_TO_FINALIZER_WILDCARD   = "<OFFSET_TO_FINALIZER>";

CopyEncryptionEngine::CopyEncryptionEngine(const boost::property_tree::ptree& engineTree)
    : IMutationEngine("CopyEncryptionEngine")
    , IXMLParser("CopyEncryptionEngine")
{
    validateSubtree(engineTree);

    for(const boost::property_tree::ptree::value_type& node : engineTree)
    {
        std::string nodeName = node.first.data();
        if(!findInRequiredSubnodes(nodeName))
            continue;

        if(nodeName == "Configuration")
            readConfiguration(node.second);
        else if(nodeName == "CodeProvider")
            readCodeProvider(node.second);
    }
}

void CopyEncryptionEngine::mutate(std::shared_ptr<PEFile> PE, std::map<std::string, std::string>& context)
{
    LOG_EMPTY();
    LOG_INFO("Starting mutation...");

    // if not first decoder, get data from previous decoders
    size_t prevDecodersSize = 0;
    if(!m_isFirst)
    {
        // retrieve previous decoders size
        auto prevDecodersSizeIt = context.find("prevDecodersSize");
        if(prevDecodersSizeIt == context.end())
            throw std::runtime_error(MODULE_NAME + " not first copy encryption engine does not inherit prevDecodersSize");

        std::string prevDecodersSizeStr = prevDecodersSizeIt->second;
        prevDecodersSize = static_cast<size_t>(std::stoul(prevDecodersSizeStr.c_str(), 0));
    }

    // retrieve exiled code size
    auto exiledCodeSizeIt = context.find("exiledCodeSize");
    if(exiledCodeSizeIt == context.end())
        throw std::runtime_error(MODULE_NAME + " copy encryption engine does not inherit exiledCodeSize");

    std::string exiledCodeSizeStr = exiledCodeSizeIt->second;
    size_t exiledCodeSize = static_cast<size_t>(std::stoul(exiledCodeSizeStr.c_str(), 0));

    // retrieve exiled code RVA
    auto exiledCodeRVAIt = context.find("exiledCodeRVA");
    if(exiledCodeRVAIt == context.end())
        throw std::runtime_error(MODULE_NAME + " copy encryption engine does not inherit exiledCodeRVA");

    std::string exiledCodeRVAStr = exiledCodeRVAIt->second;
    unsigned long exiledCodeRVA = std::stoul(exiledCodeRVAStr.c_str(), 0);

    unsigned long entryPointRVA = PE->getNTHeaders()->OptionalHeader.AddressOfEntryPoint;
    std::shared_ptr<PESection> codeSection = PE->RVAToSection(entryPointRVA);
    std::shared_ptr<std::vector<uint8_t>> code = codeSection->getData();

    CodeSectionLayoutAnalyzer codeSectionLayoutAnalyzer;
    unsigned long entryPointOffset = entryPointRVA - codeSection->getSectionHeader()->VirtualAddress;
    size_t codeBeginningOffset = codeSectionLayoutAnalyzer.checkCodeBeginningOffset(entryPointRVA, PE);
    size_t codeBeginningRVA = entryPointRVA - (entryPointOffset - codeBeginningOffset);
    size_t codeSize = codeSectionLayoutAnalyzer.checkRealCodeSize(entryPointRVA, PE);
    size_t codeEnd = codeBeginningOffset + codeSize;
    size_t sparedCodeSize = codeSize - (exiledCodeSize - prevDecodersSize);
    size_t finalizerOffset = code->size() - codeBeginningOffset - (exiledCodeSize - prevDecodersSize);
    size_t exiledCodeOffset = exiledCodeRVA - codeBeginningRVA - (exiledCodeSize - prevDecodersSize);

    SHOW_HEX(entryPointRVA);
    SHOW_HEX(entryPointOffset);
    SHOW_HEX(codeBeginningOffset);
    SHOW_HEX(codeBeginningRVA);
    SHOW_HEX(codeSize);
    SHOW_HEX(codeEnd);
    SHOW_HEX(prevDecodersSize);
    SHOW_HEX(sparedCodeSize);
    SHOW_HEX(exiledCodeSize);
    SHOW_HEX(exiledCodeOffset);
    SHOW_HEX(finalizerOffset);

    registerWildcards(sparedCodeSize, exiledCodeSize, exiledCodeOffset, finalizerOffset);
    std::vector<uint8_t> decoderCode = m_decoderCodeProvider->getUserCode();

    if(prevDecodersSize + decoderCode.size() >= codeSize)
    {
        std::stringstream msg;
        msg << MODULE_NAME + " total size of decoders is greater than total size of code in PE "
            << "[all decoders: "      << std::hex << std::showbase << exiledCodeSize     << "], "
            << "[current decoders: "  << std::hex << std::showbase << prevDecodersSize   << "], "
            << "[PE code: "           << std::hex << std::showbase << codeSize           << "], "
            << "[this decoder size: " << std::hex << std::showbase << decoderCode.size() << "]";

        throw std::runtime_error(msg.str());
    }

    // encode spared code (without additional data directory data)
    uint8_t encryptionKeyByte = static_cast<uint8_t>(std::stoul(m_encryptionKey.c_str(), 0, 16));
    size_t sparedCodeOffset = codeBeginningOffset + exiledCodeSize - prevDecodersSize;
    for(size_t i = sparedCodeOffset; i < codeEnd; ++i)
        code->at(i) ^= encryptionKeyByte;

    // encode exiled code
    std::shared_ptr<PESection> exiledCodeSection = PE->RVAToSection(exiledCodeRVA);
    size_t exiledCodeInternalOffset = exiledCodeRVA - exiledCodeSection->getSectionHeader()->VirtualAddress;
    std::shared_ptr<std::vector<uint8_t>> exiledCode = exiledCodeSection->getData();

    for(size_t i = exiledCodeInternalOffset; i < exiledCode->size(); ++i)
        exiledCode->at(i) ^= encryptionKeyByte;

    // insert decoder at the beginning of code segment (but after all previous decoders)
    size_t insertDecoderOffset = codeBeginningOffset + exiledCodeSize - prevDecodersSize - decoderCode.size();
    for(size_t i = 0, j = insertDecoderOffset; i < decoderCode.size(); ++i, ++j)
        (*code)[j] = decoderCode[i];

    // make code and exiled segments writeable
    codeSection->getSectionHeader()->Characteristics |= IMAGE_SCN_MEM_WRITE;
    exiledCodeSection->getSectionHeader()->Characteristics |= IMAGE_SCN_MEM_WRITE;

    // set flag indicating that binary has to be loaded at preferred location
    PE->getNTHeaders()->FileHeader.Characteristics |= IMAGE_FILE_RELOCS_STRIPPED;

    // update context in case other encryption modules will use it
    prevDecodersSize += decoderCode.size();
    context["prevDecodersSize"] = std::to_string(prevDecodersSize);

    LOG_INFO("Mutation success!");
}

std::vector<std::string>& CopyEncryptionEngine::getRequiredSubnodes()
{
    static std::vector<std::string> requiredSubnodes = boost::assign::list_of("Configuration")
                                                                             ("*CodeProvider")
                                                                             ;
    return requiredSubnodes;
}

void CopyEncryptionEngine::readConfiguration(const boost::property_tree::ptree& configurationTree)
{
    m_isFirst = configurationTree.get<bool>("<xmlattr>.isFirst", false);
    m_encryptionKey = configurationTree.get<std::string>("<xmlattr>.encryptionKey", "");
}

void CopyEncryptionEngine::readCodeProvider(const boost::property_tree::ptree& codeProviderTree)
{
    std::shared_ptr<ICodeProvider> codeProvider = ICodeProvider::create(codeProviderTree, false);
    std::string providerId = codeProviderTree.get<std::string>("<xmlattr>.id", "");
    if(providerId == "decoder")
        m_decoderCodeProvider = codeProvider;
    else if(providerId == "garbage")
        m_garbageCodeProvider = codeProvider;
}

void CopyEncryptionEngine::registerWildcards(size_t sparedCodeSize, size_t exiledCodeSize, size_t exiledCodeOffset, size_t finalizerOffset)
{
    // in XML there is opposite order than in execution
    std::stringstream isLastStr;
    isLastStr << std::hex << std::showbase << (m_isFirst ? 1 : 0);

    std::stringstream sparedCodeSizeStr;
    sparedCodeSizeStr << std::hex << std::showbase << sparedCodeSize;

    std::stringstream exiledCodeSizeStr;
    exiledCodeSizeStr << std::hex << std::showbase << exiledCodeSize;

    std::stringstream exiledCodeOffsetStr;
    exiledCodeOffsetStr << std::hex << std::showbase << exiledCodeOffset;

    std::stringstream finalizerOffsetStr;
    finalizerOffsetStr << std::hex << std::showbase << finalizerOffset;

    m_decoderCodeProvider->addWildcard(IS_LAST_WILDCARD, isLastStr.str());
    m_decoderCodeProvider->addWildcard(DECODER_KEY_WILDCARD, m_encryptionKey);
    m_decoderCodeProvider->addWildcard(SPARED_CODE_SIZE_WILDCARD, sparedCodeSizeStr.str());
    m_decoderCodeProvider->addWildcard(EXILED_CODE_SIZE_WILDCARD, exiledCodeSizeStr.str());
    m_decoderCodeProvider->addWildcard(OFFSET_TO_EXILED_CODE_WILDCARD, exiledCodeOffsetStr.str());
    m_decoderCodeProvider->addWildcard(OFFSET_TO_FINALIZER_WILDCARD, finalizerOffsetStr.str());
    
}