#include "ResourceExtractor.h"
#include "PortableExecutable\Resources\ResourcesSection.h"
#include "PortableExecutable\Resources\ResourceEntry.h"
#include "Utils\Debug\Debug.h"

#include <stdexcept>
#include <fstream>
#include <boost\range\adaptors.hpp>
#include <boost\assign\list_of.hpp>

ResourceExtractor::ResourceExtractor(const boost::property_tree::ptree& engineTree)
    : IMutationEngine("ResourceExtractor")
    , IXMLParser("ResourceExtractor")
{
    validateSubtree(engineTree);

    for(const boost::property_tree::ptree::value_type& node : engineTree)
    {
        std::string nodeName = node.first.data();
        if(!findInRequiredSubnodes(nodeName))
            continue;

        if(nodeName == "Resource")
            readResource(node.second);
    }
}

void ResourceExtractor::mutate(std::shared_ptr<PEFile> PE, std::map<std::string, std::string>& context)
{
    std::shared_ptr<ResourcesSection> resourceSection = std::static_pointer_cast<ResourcesSection>(PE->getDataDirectory()->getEntry(DataDirectoryType::RESOURCE));

    for(unsigned int removeId : m_extractedResources | boost::adaptors::map_keys)
    {
        ResourceIterator it(resourceSection->getRoot());
        std::shared_ptr<ResourceEntry> resource;
        while(resource = it.getNext())
        {
            unsigned long resourceId = resource->getId();
            if(resourceId != removeId)
                continue;

            std::ofstream file;
            file.open(m_extractedResources[resourceId], std::ios::out | std::ios::binary);
            std::shared_ptr<std::vector<uint8_t>> resourceData = resource->getResource();
            for(unsigned int i = 0; i < resourceData->size(); ++i)
                file.write(reinterpret_cast<char*>(&resourceData->at(i)), 1);

            file.close();
            break;
        }
    }
}

std::vector<std::string>& ResourceExtractor::getRequiredSubnodes()
{
    static std::vector<std::string> requiredSubnodes = boost::assign::list_of("*Resource")
                                                                             ;
    return requiredSubnodes;
}

void ResourceExtractor::readResource(const boost::property_tree::ptree& resourceTree)
{
    std::string outputPath = resourceTree.get<std::string>("<xmlattr>.path", "");
    unsigned int resourceType = resourceTree.get<unsigned int>("<xmlattr>.type", 0);

    if(outputPath == "" || resourceType == 0)
        throw std::runtime_error(MODULE_NAME + " one or more attributes is empty in Resource node");

    m_extractedResources[resourceType] = outputPath;
}