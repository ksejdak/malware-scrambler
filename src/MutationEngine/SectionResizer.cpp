#include "SectionResizer.h"
#include "Utils\Debug\Debug.h"

#include <stdexcept>
#include <algorithm>
#include <map>
#include <boost\range\adaptor\map.hpp>

SectionResizer::SectionResizer(const boost::property_tree::ptree& engineTree)
    : IMutationEngine("SectionResizer")
{
}

void SectionResizer::mutate(std::shared_ptr<PEFile> PE, std::map<std::string, std::string>& context)
{
    identifyFieldsToUpdate(PE);

    unsigned long sectionAlignment = PE->getNTHeaders()->OptionalHeader.SectionAlignment;
    unsigned long fileAlignment = PE->getNTHeaders()->OptionalHeader.FileAlignment;

    unsigned long previousSectionVirtualEnd = 0;
    unsigned long previousSectionRawEnd = 0;

    size_t sectionsOverallRawSize = 0;

    for(std::string sectionName : PE->getSectionsOrder())
    {
        std::shared_ptr<PESection> section = PE->getSections()[sectionName];

        // align data size
        size_t dataSize = section->getDataSize();

        size_t virtualPaddingSize = 0;
        if(section->isShrinked())
            virtualPaddingSize = (dataSize % sectionAlignment) ? sectionAlignment - (dataSize % sectionAlignment) : 0;
        else
            virtualPaddingSize = (section->getVirtualSize() % sectionAlignment) ? sectionAlignment - (section->getVirtualSize() % sectionAlignment) : 0;
            
        size_t filePaddingSize = (dataSize % fileAlignment) ? fileAlignment - (dataSize % fileAlignment) : 0;

        section->getSectionHeader()->Misc.VirtualSize = (section->isShrinked()) ? dataSize : section->getVirtualSize();
        section->getSectionHeader()->SizeOfRawData = dataSize + filePaddingSize;

        // align section RVA and file offset
        bool isFirst = (PE->getSectionsOrder().front() == sectionName);
        if(isFirst)
        {
            // first section will always start at default file offset and default RVA
            section->getSectionHeader()->VirtualAddress = m_firstSectionRVA;
            section->getSectionHeader()->PointerToRawData = m_firstSectionOffset;
        }
        else
        {
            // other sections will always start at the end of previous section's end
            section->getSectionHeader()->VirtualAddress = previousSectionVirtualEnd;
            section->getSectionHeader()->PointerToRawData = previousSectionRawEnd;
        }

        previousSectionVirtualEnd = section->getSectionHeader()->VirtualAddress + section->getVirtualSize() + virtualPaddingSize;

        if(section->getRawSize())
            previousSectionRawEnd = section->getSectionHeader()->PointerToRawData + section->getRawSize();
        else
            previousSectionRawEnd = m_firstFileSectionOffset;

        sectionsOverallRawSize += section->getRawSize();

        updateFields(PE, section);
    }

    updateDataDirectory(PE);
    PE->getNTHeaders()->OptionalHeader.SizeOfImage = previousSectionVirtualEnd;
    PE->setFileSize(previousSectionRawEnd);
}

void SectionResizer::identifyFieldsToUpdate(std::shared_ptr<PEFile> PE)
{
    identifyFirstSectionPosition(PE);
    identifyPEHeaderFieldsToUpdate(PE);
    identifyDataDirectoriesToUpdate(PE);
}

void SectionResizer::identifyFirstSectionPosition(std::shared_ptr<PEFile> PE)
{
    std::string firstSectionName = PE->getSectionsOrder().front();
    m_firstSectionRVA = PE->getSections()[firstSectionName]->getSectionHeader()->VirtualAddress;
    m_firstSectionOffset = PE->getSections()[firstSectionName]->getSectionHeader()->PointerToRawData;

    for(std::shared_ptr<PESection> section : PE->getSections() | boost::adaptors::map_values)
    {
        if(section->getRawSize() == 0)
            continue;

        m_firstFileSectionOffset = section->getSectionHeader()->PointerToRawData;
        break;
    }
}

void SectionResizer::identifyPEHeaderFieldsToUpdate(std::shared_ptr<PEFile> PE)
{
    unsigned long baseOfCode = PE->getNTHeaders()->OptionalHeader.BaseOfCode;
    m_baseOfCodeSectionName = PE->RVAToSection(baseOfCode)->getName();

    unsigned long baseOfData = PE->getNTHeaders()->OptionalHeader.BaseOfData;
    m_baseOfDataSectionName = PE->RVAToSection(baseOfData)->getName();
}

void SectionResizer::identifyDataDirectoriesToUpdate(std::shared_ptr<PEFile> PE)
{
    for(int i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; ++i)
    {
        unsigned long dataDirectoryRVA = PE->getNTHeaders()->OptionalHeader.DataDirectory[i].VirtualAddress;
        if(dataDirectoryRVA == 0)
            continue;

        try
        {
            std::shared_ptr<PESection> holdingSection = PE->RVAToSection(dataDirectoryRVA);
            DataDirectoryUpdate dataDirectoryUpdate =
            {
                holdingSection->getName(),
                holdingSection->getSectionHeader()->VirtualAddress,
                0 // will be set after resizing
            };

            DataDirectoryType dataDirectoryType = static_cast<DataDirectoryType>(i);
            m_dataDirectoriesToUpdate[dataDirectoryType] = dataDirectoryUpdate;
        }
        catch(const std::exception&)
        {
            // this means, that given data directory is not within scope of any section. The only supported (for now) situation is
            // when virtual address represents file offset and is located before first section. In such a case we can skip it.
            LOG_INFO("Data directory entry [id: " + std::to_string(i) + "] is not within scope of any section");
        }
    }
}

void SectionResizer::updateFields(std::shared_ptr<PEFile> PE, std::shared_ptr<PESection> resizedSection)
{
    updatePEStructures(PE, resizedSection);
    updateDataDirectoryUpdates(PE, resizedSection);
}

void SectionResizer::updatePEStructures(std::shared_ptr<PEFile> PE, std::shared_ptr<PESection> resizedSection)
{
    std::string resizedSectionName = resizedSection->getName();

    if(resizedSectionName == m_baseOfCodeSectionName)
        PE->getNTHeaders()->OptionalHeader.BaseOfCode = resizedSection->getSectionHeader()->VirtualAddress;
    else if(resizedSectionName == m_baseOfDataSectionName)
        PE->getNTHeaders()->OptionalHeader.BaseOfData = resizedSection->getSectionHeader()->VirtualAddress;
}

void SectionResizer::updateDataDirectoryUpdates(std::shared_ptr<PEFile> PE, std::shared_ptr<PESection> resizedSection)
{
    for(DataDirectoryUpdate& dataDirectoryUpdate : m_dataDirectoriesToUpdate | boost::adaptors::map_values)
    {
        if(dataDirectoryUpdate.holdingSectionName == resizedSection->getName())
            dataDirectoryUpdate.newSectionRVA = resizedSection->getSectionHeader()->VirtualAddress;
    }
}

void SectionResizer::updateDataDirectory(std::shared_ptr<PEFile> PE)
{
    std::shared_ptr<DataDirectory> dataDirectory = PE->getDataDirectory();
    unsigned short fileFlags = PE->getNTHeaders()->FileHeader.Characteristics;
    bool areRelocationsStripped = ((fileFlags & IMAGE_FILE_RELOCS_STRIPPED) == IMAGE_FILE_RELOCS_STRIPPED);

    for(DataDirectoryType dataDirectoryType : m_dataDirectoriesToUpdate | boost::adaptors::map_keys)
    {
        DataDirectoryUpdate dataDirectoryUpdate = m_dataDirectoriesToUpdate[dataDirectoryType];
        unsigned long RVADiff = dataDirectoryUpdate.newSectionRVA - dataDirectoryUpdate.oldSectionRVA;
        if(RVADiff && areRelocationsStripped)
            throw std::runtime_error(MODULE_NAME + " cannot resize sections when relocations are stripped");

        std::shared_ptr<DataDirectoryEntry> dataDirectoryEntry = dataDirectory->getEntry(dataDirectoryType);
        unsigned long oldEntryRVA = dataDirectoryEntry->getRVA();
        dataDirectoryEntry->setRVA(oldEntryRVA + RVADiff);
        dataDirectoryEntry->addToRVAs(RVADiff);
    }
}