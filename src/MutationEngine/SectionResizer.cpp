#include "SectionResizer.h"
#include "Utils\Debug\Debug.h"

#include <stdexcept>
#include <algorithm>
#include <map>
#include <boost\range\adaptor\map.hpp>

SectionResizer::SectionResizer(const boost::property_tree::ptree& engineTree)
    : IMutationEngine("SectionResizer")
{
}

void SectionResizer::mutate(std::shared_ptr<PEFile> PE, std::map<std::string, std::string>& context)
{
    identifyFieldsToUpdate(PE);

    unsigned long sectionAlignment = PE->getNTHeaders()->OptionalHeader.SectionAlignment;
    unsigned long fileAlignment = PE->getNTHeaders()->OptionalHeader.FileAlignment;

    unsigned long previousSectionVirtualEnd = 0;
    unsigned long previousSectionRawEnd = 0;

    size_t sectionsOverallRawSize = 0;

    for(std::string sectionName : PE->getSectionsOrder())
    {
        std::shared_ptr<PESection> section = PE->getSections()[sectionName];

        // align data size
        size_t dataSize = section->getDataSize();

        size_t virtualPaddingSize = 0;
        if(section->isShrinked())
            virtualPaddingSize = (dataSize % sectionAlignment) ? sectionAlignment - (dataSize % sectionAlignment) : 0;
        else
            virtualPaddingSize = (section->getVirtualSize() % sectionAlignment) ? sectionAlignment - (section->getVirtualSize() % sectionAlignment) : 0;
            
        size_t filePaddingSize = (dataSize % fileAlignment) ? fileAlignment - (dataSize % fileAlignment) : 0;

        section->getSectionHeader()->Misc.VirtualSize = (section->isShrinked()) ? dataSize : section->getVirtualSize();
        section->getSectionHeader()->SizeOfRawData = dataSize + filePaddingSize;

        // align section RVA and file offset
        bool isFirst = (PE->getSectionsOrder().front() == sectionName);
        if(isFirst)
        {
            // first section will always start at default file offset and default RVA
            section->getSectionHeader()->VirtualAddress = m_firstSectionRVA;
            section->getSectionHeader()->PointerToRawData = m_firstSectionOffset;
        }
        else
        {
            // other sections will always start at the end of previous section's end
            section->getSectionHeader()->VirtualAddress = previousSectionVirtualEnd;
            section->getSectionHeader()->PointerToRawData = previousSectionRawEnd;
        }

        previousSectionVirtualEnd = section->getSectionHeader()->VirtualAddress + section->getVirtualSize() + virtualPaddingSize;

        if(section->getRawSize())
            previousSectionRawEnd = section->getSectionHeader()->PointerToRawData + section->getRawSize();
        else
            previousSectionRawEnd = m_firstFileSectionOffset;

        sectionsOverallRawSize += section->getRawSize();

        updateFields(PE, section);
    }

    // last section's raw end indicates size of whole PE file
    PE->setFileSize(previousSectionRawEnd);
}

void SectionResizer::identifyFieldsToUpdate(std::shared_ptr<PEFile> PE)
{
    identifyPEHeaderFieldsToUpdate(PE);
    identifyDataDirectoriesToUpdate(PE);
    identifyFirstSectionPosition(PE);
}

void SectionResizer::identifyPEHeaderFieldsToUpdate(std::shared_ptr<PEFile> PE)
{
    unsigned long baseOfCode = PE->getNTHeaders()->OptionalHeader.BaseOfCode;
    m_baseOfCodeSectionName = PE->RVAToSection(baseOfCode)->getName();

    unsigned long baseOfData = PE->getNTHeaders()->OptionalHeader.BaseOfData;
    m_baseOfDataSectionName = PE->RVAToSection(baseOfData)->getName();
}

void SectionResizer::identifyDataDirectoriesToUpdate(std::shared_ptr<PEFile> PE)
{
    for(int i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; ++i)
    {
        unsigned long dataDirectoryRVA = PE->getNTHeaders()->OptionalHeader.DataDirectory[i].VirtualAddress;
        if(dataDirectoryRVA == 0)
            continue;

        try
        {
            std::shared_ptr<PESection> holdingSection = PE->RVAToSection(dataDirectoryRVA);
            std::string holdingSectionName = holdingSection->getName();
            unsigned long offsetInSection = dataDirectoryRVA - holdingSection->getSectionHeader()->VirtualAddress;
            m_dataDirectoriesToUpdated[i] = std::make_pair(holdingSectionName, offsetInSection);
        }
        catch(std::exception&)
        {
            // this means, that given data directory is not within scope of any section. The only supported (for now) situation is
            // when virtual address represents file offset and is located before first section. In such a case we can skip it.
            LOG_INFO("Data directory entry [id: " + std::to_string(i) + "] is not within scope of any section");
        }
    }
}

void SectionResizer::identifyFirstSectionPosition(std::shared_ptr<PEFile> PE)
{
    std::string firstSectionName = PE->getSectionsOrder().front();
    m_firstSectionRVA = PE->getSections()[firstSectionName]->getSectionHeader()->VirtualAddress;
    m_firstSectionOffset = PE->getSections()[firstSectionName]->getSectionHeader()->PointerToRawData;

    for(std::shared_ptr<PESection> section : PE->getSections() | boost::adaptors::map_values)
    {
        if(section->getRawSize() == 0)
            continue;

        m_firstFileSectionOffset = section->getSectionHeader()->PointerToRawData;
        break;
    }
}

void SectionResizer::updateFields(std::shared_ptr<PEFile> PE, std::shared_ptr<PESection> resizedSection)
{
    updatePEStructures(PE, resizedSection);
    updateDataDirectoryEntries(PE, resizedSection);
}

void SectionResizer::updatePEStructures(std::shared_ptr<PEFile> PE, std::shared_ptr<PESection> resizedSection)
{
    std::string resizedSectionName = resizedSection->getName();

    if(resizedSectionName == m_baseOfCodeSectionName)
        PE->getNTHeaders()->OptionalHeader.BaseOfCode = resizedSection->getSectionHeader()->VirtualAddress;
    else if(resizedSectionName == m_baseOfDataSectionName)
        PE->getNTHeaders()->OptionalHeader.BaseOfData = resizedSection->getSectionHeader()->VirtualAddress;
}

void SectionResizer::updateDataDirectoryEntries(std::shared_ptr<PEFile> PE, std::shared_ptr<PESection> resizedSection)
{
    std::string resizedSectionName = resizedSection->getName();
    for(int i : m_dataDirectoriesToUpdated | boost::adaptors::map_keys)
    {
        if(m_dataDirectoriesToUpdated[i].first != resizedSectionName)
            continue;

        unsigned long resizedSectionRVA = resizedSection->getSectionHeader()->VirtualAddress;
        unsigned long offsetInSection = m_dataDirectoriesToUpdated[i].second;
        PE->getNTHeaders()->OptionalHeader.DataDirectory[i].VirtualAddress = resizedSectionRVA + offsetInSection;
    }
}