#include "SectionResizer.h"
#include "Utils\Debug\Debug.h"

#include <stdexcept>
#include <algorithm>
#include <map>
#include <boost\range\adaptor\map.hpp>

const static unsigned long FIRST_SECTION_VIRTUAL_START  = 0x1000;
const static unsigned long FIRST_SECTION_RAW_START      = 0x400;

SectionResizer::SectionResizer(const boost::property_tree::ptree& engineTree)
    : IMutationEngine("SectionResizer")
{
}

void SectionResizer::mutate(std::shared_ptr<PEFile> PE, std::map<std::string, std::string>& context)
{
    identifyDataDirectoriesToUpdate(PE);

    unsigned long sectionAlignment = PE->getNTHeaders()->OptionalHeader.SectionAlignment;
    unsigned long fileAlignment = PE->getNTHeaders()->OptionalHeader.FileAlignment;

    unsigned long previousSectionVirtualEnd = 0;
    unsigned long previousSectionRawEnd = 0;

    size_t sectionsOverallRawSize = 0;

    for(std::string sectionName : PE->getSectionsOrder())
    {
        std::shared_ptr<PESection> section = PE->getSections()[sectionName];

        // align data size
        size_t dataSize = section->getDataSize();

        size_t virtualPaddingSize = 0;
        if(sectionName == ".data")
            virtualPaddingSize = (section->getVirtualSize() % sectionAlignment) ? sectionAlignment - (section->getVirtualSize() % sectionAlignment) : 0;
        else
            virtualPaddingSize = (dataSize % sectionAlignment) ? sectionAlignment - (dataSize % sectionAlignment) : 0;
        size_t filePaddingSize = (dataSize % fileAlignment) ? fileAlignment - (dataSize % fileAlignment) : 0;

        section->getSectionHeader()->Misc.VirtualSize = (section->getName() == ".data") ? section->getVirtualSize() : dataSize;
        section->getSectionHeader()->SizeOfRawData = dataSize + filePaddingSize;

        // align section RVA and file offset
        bool isFirst = (PE->getSectionsOrder().front() == sectionName);
        if(isFirst)
        {
            // first section will always start at default file offset and default RVA
            section->getSectionHeader()->VirtualAddress = FIRST_SECTION_VIRTUAL_START;
            section->getSectionHeader()->PointerToRawData = FIRST_SECTION_RAW_START;
        }
        else
        {
            // other sections will always start at the end of previous section's end
            section->getSectionHeader()->VirtualAddress = previousSectionVirtualEnd;
            section->getSectionHeader()->PointerToRawData = previousSectionRawEnd;
        }

        previousSectionVirtualEnd = section->getSectionHeader()->VirtualAddress + section->getVirtualSize() + virtualPaddingSize;
        previousSectionRawEnd = section->getSectionHeader()->PointerToRawData + section->getRawSize();

        sectionsOverallRawSize += section->getRawSize();

        updatePEStructures(PE, section);
    }

    // last section's raw end indicates size of whole PE file
    PE->setFileSize(previousSectionRawEnd);
}

void SectionResizer::identifyDataDirectoriesToUpdate(std::shared_ptr<PEFile> PE)
{
    for(int i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; ++i)
    {
        unsigned long dataDirectoryRVA = PE->getNTHeaders()->OptionalHeader.DataDirectory[i].VirtualAddress;
        if(dataDirectoryRVA == 0)
            continue;

        try
        {
            std::shared_ptr<PESection> holdingSection = PE->RVAToSection(dataDirectoryRVA);
            std::string holdingSectionName = holdingSection->getName();
            unsigned long offsetInSection = dataDirectoryRVA - holdingSection->getSectionHeader()->VirtualAddress;
            m_dataDirectoriesToUpdated[i] = std::make_pair(holdingSectionName, offsetInSection);
        }
        catch(std::exception&)
        {
            // this means, that given data directory is not within scope of any section. The only supported (for now) situation is
            // when virtual address represents file offset and is located before first section. In such a case we can skip it.
            LOG_INFO("Data directory entry [id: " + std::to_string(i) + "] is not within scope of any section");
        }
    }
}

void SectionResizer::updatePEStructures(std::shared_ptr<PEFile> PE, std::shared_ptr<PESection> resizedSection)
{
    std::string resizedSectionName = resizedSection->getName();

    // update some PE header fields
    if(resizedSectionName == ".text")
        PE->getNTHeaders()->OptionalHeader.BaseOfCode = resizedSection->getSectionHeader()->VirtualAddress;
    else if(resizedSectionName == ".rdata")
        PE->getNTHeaders()->OptionalHeader.BaseOfData = resizedSection->getSectionHeader()->VirtualAddress;

    updateDataDirectoryEntries(PE, resizedSection);
}

void SectionResizer::updateDataDirectoryEntries(std::shared_ptr<PEFile> PE, std::shared_ptr<PESection> resizedSection)
{
    std::string resizedSectionName = resizedSection->getName();
    for(int i : m_dataDirectoriesToUpdated | boost::adaptors::map_keys)
    {
        if(m_dataDirectoriesToUpdated[i].first != resizedSectionName)
            continue;

        unsigned long resizedSectionRVA = resizedSection->getSectionHeader()->VirtualAddress;
        unsigned long offsetInSection = m_dataDirectoriesToUpdated[i].second;
        PE->getNTHeaders()->OptionalHeader.DataDirectory[i].VirtualAddress = resizedSectionRVA + offsetInSection;
    }
}