#include "IATDeleterEngine.h"
#include "PortableExecutable\PortableExecutableCommon\CodeSectionLayoutAnalyzer.h"
#include "Utils\Debug\Debug.h"

#include <sstream>
#include <boost\assign\list_of.hpp>

static const std::string IS_LAST_WILDCARD = "<IS_LAST>";

IATDeleterEngine::IATDeleterEngine(const boost::property_tree::ptree& engineTree)
    : IMutationEngine("IATDeleterEngine")
    , IXMLParser("IATDeleterEngine")
{
    validateSubtree(engineTree);

    for(const boost::property_tree::ptree::value_type& node : engineTree)
    {
        std::string nodeName = node.first.data();
        if(!findInRequiredSubnodes(nodeName))
            continue;

        if(nodeName == "Configuration")
            readConfiguration(node.second);
        else if(nodeName == "CodeProvider")
            readCodeProvider(node.second);
    }
}

void IATDeleterEngine::mutate(std::shared_ptr<PEFile> PE, std::map<std::string, std::string>& context)
{
    LOG_EMPTY();
    LOG_INFO("Starting mutation...");

    // if not first decoder, get data from previous decoders
    size_t prevEnginesSize = 0;
    if(!m_isFirst)
    {
        // retrieve previous engines size
        auto prevEnginesSizeIt = context.find("prevEnginesSize");
        if(prevEnginesSizeIt == context.end())
            throw std::runtime_error(MODULE_NAME + " not first copy encryption engine does not inherit prevEnginesSize");

        std::string prevEnginesSizeStr = prevEnginesSizeIt->second;
        prevEnginesSize = static_cast<size_t>(std::stoul(prevEnginesSizeStr.c_str(), 0));
    }

    // retrieve exiled code size
    auto exiledCodeSizeIt = context.find("exiledCodeSize");
    if(exiledCodeSizeIt == context.end())
        throw std::runtime_error(MODULE_NAME + " copy encryption engine does not inherit exiledCodeSize");

    std::string exiledCodeSizeStr = exiledCodeSizeIt->second;
    size_t exiledCodeSize = static_cast<size_t>(std::stoul(exiledCodeSizeStr.c_str(), 0));

    unsigned long entryPointRVA = PE->getNTHeaders()->OptionalHeader.AddressOfEntryPoint;
    std::shared_ptr<PESection> codeSection = PE->RVAToSection(entryPointRVA);
    std::shared_ptr<std::vector<uint8_t>> code = codeSection->getData();

    CodeSectionLayoutAnalyzer codeSectionLayoutAnalyzer;
    size_t codeBeginningOffset = codeSectionLayoutAnalyzer.checkCodeBeginningOffset(entryPointRVA, PE);
    size_t sparedCodeOffset = codeBeginningOffset + exiledCodeSize - prevEnginesSize;

    registerWildcards();
    std::vector<uint8_t> resolverCode = m_resolverCodeProvider->getUserCode();
    size_t resolverCodeSize = resolverCode.size();
    size_t insertResolverOffset = sparedCodeOffset - resolverCodeSize;

    // delete IAT

    // insert resolver code
    for(size_t i = 0, j = insertResolverOffset; i < resolverCodeSize; ++i, ++j)
        (*code)[j] = resolverCode[i];

    // update context in case other encryption modules will use it
    prevEnginesSize += resolverCodeSize;
    context["prevEnginesSize"] = std::to_string(prevEnginesSize);

    LOG_INFO("Mutation success!");
}

std::vector<std::string>& IATDeleterEngine::getRequiredSubnodes()
{
    static std::vector<std::string> requiredSubnodes = boost::assign::list_of("Configuration")
                                                                             ("CodeProvider")
                                                                             ;
    return requiredSubnodes;
}

void IATDeleterEngine::readConfiguration(const boost::property_tree::ptree& configurationTree)
{
    m_isFirst = configurationTree.get<bool>("<xmlattr>.isFirst", false);
    m_encryptionKey = configurationTree.get<std::string>("<xmlattr>.encryptionKey", "");
}

void IATDeleterEngine::readCodeProvider(const boost::property_tree::ptree& codeProviderTree)
{
    std::shared_ptr<ICodeProvider> codeProvider = ICodeProvider::create(codeProviderTree);
    std::string providerId = codeProviderTree.get<std::string>("<xmlattr>.id", "");
    if(providerId == "resolver")
        m_resolverCodeProvider = codeProvider;
}

void IATDeleterEngine::registerWildcards()
{
}