#include "IATDeleterEngine.h"
#include "PortableExecutable\PortableExecutableCommon\CodeSectionLayoutAnalyzer.h"
#include "Utils\Debug\Debug.h"

#include <sstream>
#include <boost\assign\list_of.hpp>

static const std::string OFFSET_TO_ORIGINAL_IMPORTS_WILDCARD = "<OFFSET_TO_ORIGINAL_IMPORTS>";
static const std::string OFFSET_TO_EXILED_IMPORTS_WILDCARD   = "<OFFSET_TO_EXILED_IMPORTS>";
static const std::string DECODER_KEY_WILDCARD                = "<DECODER_KEY>";
static const std::string IMPORTS_SIZE_WILDCARD               = "<IMPORTS_SIZE>";

IATDeleterEngine::IATDeleterEngine(const boost::property_tree::ptree& engineTree)
    : IMutationEngine("IATDeleterEngine")
    , IXMLParser("IATDeleterEngine")
{
    validateSubtree(engineTree);

    for(const boost::property_tree::ptree::value_type& node : engineTree)
    {
        std::string nodeName = node.first.data();
        if(!findInRequiredSubnodes(nodeName))
            continue;

        if(nodeName == "Configuration")
            readConfiguration(node.second);
        else if(nodeName == "CodeProvider")
            readCodeProvider(node.second);
    }
}

void IATDeleterEngine::mutate(std::shared_ptr<PEFile> PE, std::map<std::string, std::string>& context)
{
    LOG_EMPTY();
    LOG_INFO("Starting mutation...");

    // if not first decoder, get data from previous decoders
    size_t prevEnginesSize = 0;
    if(!m_isFirst)
    {
        // retrieve previous engines size
        auto prevEnginesSizeIt = context.find("prevEnginesSize");
        if(prevEnginesSizeIt == context.end())
            throw std::runtime_error(MODULE_NAME + " not first IAT deleter engine does not inherit prevEnginesSize");

        std::string prevEnginesSizeStr = prevEnginesSizeIt->second;
        prevEnginesSize = static_cast<size_t>(std::stoul(prevEnginesSizeStr.c_str(), 0));
    }

    // retrieve exiled code size
    auto exiledCodeSizeIt = context.find("movedCodeSize");
    if(exiledCodeSizeIt == context.end())
        throw std::runtime_error(MODULE_NAME + " IAT deleter engine does not inherit movedCodeSize");

    std::string exiledCodeSizeStr = exiledCodeSizeIt->second;
    size_t exiledCodeSize = static_cast<size_t>(std::stoul(exiledCodeSizeStr.c_str(), 0));

    // mark imports to be moved (CodeRelocationEngine required)
    unsigned long importDirectoryRVA = PE->getDataDirectory()->getEntry(DataDirectoryType::IMPORT)->getRVA();
    size_t importDirectorySize = static_cast<size_t>(PE->getDataDirectory()->getEntry(DataDirectoryType::IMPORT)->getVirtualSize());
    context["relocationSourceRVA"] = std::to_string(importDirectoryRVA);
    context["relocationSize"] = std::to_string(importDirectorySize);

    // encrypt imports
    std::shared_ptr<std::vector<uint8_t>> importData = PE->getDataDirectory()->getEntry(DataDirectoryType::IMPORT)->getData();
    unsigned long offsetToImports = PE->getDataDirectory()->getEntry(DataDirectoryType::IMPORT)->getDataOffset();
    uint8_t encryptionKeyByte = static_cast<uint8_t>(std::stoul(m_encryptionKey.c_str(), 0, 16));
    for(unsigned int i = offsetToImports; i < offsetToImports + importDirectorySize; ++i)
        (*importData)[i] ^= encryptionKeyByte;

    // "remove" all kind of imports from data directory
    PE->getDataDirectory()->getEntry(DataDirectoryType::IMPORT)->setRVA(0);
    PE->getDataDirectory()->getEntry(DataDirectoryType::BOUND_IMPORT)->setRVA(0);
    PE->getDataDirectory()->getEntry(DataDirectoryType::DELAY_IMPORT)->setRVA(0);
    PE->getDataDirectory()->getEntry(DataDirectoryType::IAT)->setRVA(0);

    // generate resolver
    unsigned long entryPointRVA = PE->getNTHeaders()->OptionalHeader.AddressOfEntryPoint;
    std::shared_ptr<PESection> codeSection = PE->RVAToSection(entryPointRVA);
    std::shared_ptr<std::vector<uint8_t>> code = codeSection->getData();

    CodeSectionLayoutAnalyzer codeSectionLayoutAnalyzer;
    size_t codeBeginningOffset = codeSectionLayoutAnalyzer.checkCodeBeginningOffset(entryPointRVA, PE);
    size_t sparedCodeOffset = codeBeginningOffset + exiledCodeSize - prevEnginesSize;
    unsigned long sparedCodeRVA = codeSection->getSectionHeader()->VirtualAddress + sparedCodeOffset;
    unsigned long offsetToOriginalImports = sparedCodeRVA - importDirectoryRVA;
    std::string lastSectionName = PE->getSectionsOrder().back();
    std::shared_ptr<PESection> lastSection = PE->getSections()[lastSectionName];
    // +1, because we need address of byte after this section (it will be valid after CodeRelocationEngine is applied)
    unsigned long offsetToExiledImports = lastSection->getSectionHeader()->VirtualAddress + lastSection->getVirtualSize() + 1;

    registerWildcards(offsetToOriginalImports, offsetToExiledImports, importDirectorySize);
    std::vector<uint8_t> resolverCode = m_resolverCodeProvider->getUserCode();
    size_t resolverCodeSize = resolverCode.size();
    size_t insertResolverOffset = sparedCodeOffset - resolverCodeSize;

    // insert resolver code
    for(size_t i = 0, j = insertResolverOffset; i < resolverCodeSize; ++i, ++j)
        (*code)[j] = resolverCode[i];

    // update context in case other encryption modules will use it
    prevEnginesSize += resolverCodeSize;
    context["prevEnginesSize"] = std::to_string(prevEnginesSize);

    LOG_INFO("Mutation success!");
}

std::vector<std::string>& IATDeleterEngine::getRequiredSubnodes()
{
    static std::vector<std::string> requiredSubnodes = boost::assign::list_of("Configuration")
                                                                             ("CodeProvider")
                                                                             ;
    return requiredSubnodes;
}

void IATDeleterEngine::readConfiguration(const boost::property_tree::ptree& configurationTree)
{
    m_isFirst = configurationTree.get<bool>("<xmlattr>.isFirst", false);
    m_encryptionKey = configurationTree.get<std::string>("<xmlattr>.encryptionKey", "");
}

void IATDeleterEngine::readCodeProvider(const boost::property_tree::ptree& codeProviderTree)
{
    std::shared_ptr<ICodeProvider> codeProvider = ICodeProvider::create(codeProviderTree);
    std::string providerId = codeProviderTree.get<std::string>("<xmlattr>.id", "");
    if(providerId == "resolver")
        m_resolverCodeProvider = codeProvider;
}

void IATDeleterEngine::registerWildcards(unsigned long offsetToOriginalImports, unsigned long offsetToExiledImports, size_t importsSize)
{
    std::stringstream offsetToOriginalImportsStr;
    offsetToOriginalImportsStr << std::hex << std::showbase << offsetToOriginalImports;

    std::stringstream offsetToExiledImportsStr;
    offsetToExiledImportsStr << std::hex << std::showbase << offsetToExiledImports;

    std::stringstream importsSizeStr;
    importsSizeStr << std::hex << std::showbase << importsSize;

    m_resolverCodeProvider->addWildcard(OFFSET_TO_ORIGINAL_IMPORTS_WILDCARD, offsetToOriginalImportsStr.str());
    m_resolverCodeProvider->addWildcard(OFFSET_TO_EXILED_IMPORTS_WILDCARD, offsetToExiledImportsStr.str());
    m_resolverCodeProvider->addWildcard(DECODER_KEY_WILDCARD, m_encryptionKey);
    m_resolverCodeProvider->addWildcard(IMPORTS_SIZE_WILDCARD, importsSizeStr.str());
}