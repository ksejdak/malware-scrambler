#include "EncryptionEngine.h"
#include "PortableExecutable\PortableExecutableCommon\CodeSectionLayoutAnalyzer.h"
#include "Utils\Debug\Debug.h"

#include <boost\assign\list_of.hpp>

static const std::string OFFSET_TO_CODE_BOTTOM_WILDCARD = "<OFFSET_TO_CODE_BOTTOM>";
static const std::string DECODER_KEY_WILDCARD           = "<DECODER_KEY>";
static const std::string CODE_SIZE_WILDCARD             = "<CODE_SIZE>";
static const std::string OFFSET_TO_ENTRY_POINT_WILDCARD = "<OFFSET_TO_ENTRY_POINT>";
static const std::string PREV_DECODER_SIZE_WILDCARD     = "<PREV_DECODER_SIZE>";
static const std::string DELAY_SECS_WILDCARD            = "<DELAY_SECS>";

EncryptionEngine::EncryptionEngine(const boost::property_tree::ptree& engineTree)
    : IMutationEngine("EncryptionEngine")
    , IXMLParser("EncryptionEngine")
{
    validateSubtree(engineTree);

    for(const boost::property_tree::ptree::value_type& node : engineTree)
    {
        std::string nodeName = node.first.data();
        if(!findInRequiredSubnodes(nodeName))
            continue;

        if(nodeName == "Configuration")
            readConfiguration(node.second);
        else if(nodeName == "CodeProvider")
            readCodeProvider(node.second);
    }
}

void EncryptionEngine::mutate(std::shared_ptr<PEFile> PE, std::map<std::string, std::string>& context)
{
    LOG_EMPTY();
    LOG_INFO("Starting mutation...");

    unsigned long entryPointRVA = PE->getNTHeaders()->OptionalHeader.AddressOfEntryPoint;
    std::shared_ptr<PESection> codeSection = PE->RVAToSection(entryPointRVA);
    unsigned long entryPointOffset = entryPointRVA - codeSection->getSectionHeader()->VirtualAddress;

    if(m_isMultiple)
    {
        // retrieve first entry point offset
        auto firstEntryPointRVAIt = context.find("firstEntryPointRVA");
        if(firstEntryPointRVAIt == context.end())
            throw std::runtime_error(MODULE_NAME + " multiple encryption engine does not inherit firstEntryPointRVA");

        std::string firstEntryPointRVAStr = firstEntryPointRVAIt->second;
        entryPointRVA = std::stoul(firstEntryPointRVAStr.c_str(), 0);

        // retrieve first entry point offset
        auto firstEntryPointOffsetIt = context.find("firstEntryPointOffset");
        if(firstEntryPointOffsetIt == context.end())
            throw std::runtime_error(MODULE_NAME + " multiple encryption engine does not inherit firstEntryPointOffset");

        std::string firstEntryPointOffsetStr = firstEntryPointOffsetIt->second;
        entryPointOffset = std::stoul(firstEntryPointOffsetStr.c_str(), 0);

        // retrieve previous decoder size
        auto prevDecoderSizeIt = context.find("prevDecoderSize");
        if(prevDecoderSizeIt == context.end())
            throw std::runtime_error(MODULE_NAME + " multiple encryption engine does not inherit prevDecoderSize");

        m_prevDecoderSize = prevDecoderSizeIt->second;
        context.erase(prevDecoderSizeIt);
    }

    std::shared_ptr<std::vector<uint8_t>> code = codeSection->getData();

    CodeSectionLayoutAnalyzer codeSectionLayoutAnalyzer;
    size_t codeBeginningOffset = codeSectionLayoutAnalyzer.checkCodeBeginningOffset(entryPointRVA, PE);
    size_t codeSize = codeSectionLayoutAnalyzer.checkRealCodeSize(entryPointRVA, PE);
    size_t codeEnd = codeBeginningOffset + codeSize;
    size_t codeBottomOffset = code->size() - codeEnd;
    size_t offsetToEntryPoint = entryPointOffset - codeBeginningOffset;

    SHOW_HEX(entryPointRVA);
    SHOW_HEX(entryPointOffset);
    SHOW_HEX(codeSize);
    SHOW_HEX(codeEnd);
    SHOW_HEX(codeBottomOffset);

    size_t garbageCodeSize = 0;
    if(m_garbageCodeProvider)
    {
        m_garbageCodeProvider->addWildcard(DELAY_SECS_WILDCARD, m_delaySecs);
        std::vector<uint8_t> garbageCode = m_garbageCodeProvider->getUserCode();
        code->insert(code->end(), garbageCode.begin(), garbageCode.end());
        garbageCodeSize = garbageCode.size();
    }
    codeBottomOffset += garbageCodeSize;

    registerWildcards(codeBottomOffset, codeSize, offsetToEntryPoint);
    std::vector<uint8_t> decoderCode = m_decoderCodeProvider->getUserCode();

    // encode original code segment (without additional data directory data)
    uint8_t encryptionKeyByte = static_cast<uint8_t>(std::stoul(m_encryptionKey.c_str(), 0, 16));
    for(unsigned int i = codeBeginningOffset; i < codeEnd; ++i)
        code->at(i) ^= encryptionKeyByte;

    // insert decoder at the end of code segment
    code->insert(code->end(), decoderCode.begin(), decoderCode.end());

    // set new entry point address. Code execution should start at the beginning of inserted decoder
    unsigned long newEntryPoint = codeSection->getSectionHeader()->VirtualAddress + codeSize + codeBottomOffset;
    if(m_garbageCodeProvider)
        newEntryPoint -= garbageCodeSize;
    PE->getNTHeaders()->OptionalHeader.AddressOfEntryPoint = newEntryPoint;
    
    // make code segment writeable
    codeSection->getSectionHeader()->Characteristics |= IMAGE_SCN_MEM_WRITE;

    // set flag indicating that binary has to be loaded at preferred location
    PE->getNTHeaders()->FileHeader.Characteristics |= IMAGE_FILE_RELOCS_STRIPPED;

    // update context in case other encryption modules will use it
    if(!m_isMultiple)
    {
        context["firstEntryPointRVA"] = std::to_string(entryPointRVA);
        context["firstEntryPointOffset"] = std::to_string(entryPointOffset);
    }

    std::stringstream decoderSizeStr;
    decoderSizeStr << std::showbase << std::hex << decoderCode.size();
    context["prevDecoderSize"] = decoderSizeStr.str();

    LOG_INFO("Mutation success!");
}

std::vector<std::string>& EncryptionEngine::getRequiredSubnodes()
{
    static std::vector<std::string> requiredSubnodes = boost::assign::list_of("Configuration")
                                                                             ("*CodeProvider")
                                                                             ;
    return requiredSubnodes;
}

void EncryptionEngine::readConfiguration(const boost::property_tree::ptree& configurationTree)
{
    m_isMultiple = configurationTree.get<bool>("<xmlattr>.isMultiple", false);
    m_encryptionKey = configurationTree.get<std::string>("<xmlattr>.encryptionKey", "");
}

void EncryptionEngine::readCodeProvider(const boost::property_tree::ptree& codeProviderTree)
{
    std::shared_ptr<ICodeProvider> codeProvider = ICodeProvider::create(codeProviderTree, false);
    std::string providerId = codeProviderTree.get<std::string>("<xmlattr>.id", "");
    if(providerId == "decoder")
        m_decoderCodeProvider = codeProvider;
    else if(providerId == "garbage")
    {
        m_garbageCodeProvider = codeProvider;
        m_delaySecs = codeProviderTree.get<std::string>("<xmlattr>.delaySecs", "");
    }
}

void EncryptionEngine::registerWildcards(size_t codeBottomOffset, size_t codeSize, size_t offsetToEntryPoint)
{
    std::stringstream codeBottomOffsetStr;
    codeBottomOffsetStr << std::hex << std::showbase << codeBottomOffset;

    std::stringstream codeSizeStr;
    codeSizeStr << std::hex << std::showbase << codeSize;

    std::stringstream offsetToEntryPointStr;
    offsetToEntryPointStr << std::hex << std::showbase << offsetToEntryPoint;

    m_decoderCodeProvider->addWildcard(OFFSET_TO_CODE_BOTTOM_WILDCARD, codeBottomOffsetStr.str());
    m_decoderCodeProvider->addWildcard(DECODER_KEY_WILDCARD, m_encryptionKey);
    m_decoderCodeProvider->addWildcard(CODE_SIZE_WILDCARD, codeSizeStr.str());

    if(!m_isMultiple)
        m_decoderCodeProvider->addWildcard(OFFSET_TO_ENTRY_POINT_WILDCARD, offsetToEntryPointStr.str());

    if(m_isMultiple)
        m_decoderCodeProvider->addWildcard(PREV_DECODER_SIZE_WILDCARD, m_prevDecoderSize);
}