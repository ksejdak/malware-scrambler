#include "EncryptionEngine.h"
#include "Utils\Assembler\TemplateAssembler.h"
#include "Utils\Debug\Debug.h"

EncryptionEngine::EncryptionEngine(const boost::property_tree::ptree& engineTree)
    : IMutationEngine("EncryptionEngine")
{
    bool codeTemplateFound = false;
    for(const boost::property_tree::ptree::value_type& node : engineTree)
    {
        if(std::string(node.first.data()) != "CodeTemplate")
            continue;

        std::string codeTemplatePath = node.second.get<std::string>("<xmlattr>.path", "");
        m_assembler = node.second.get<std::string>("<xmlattr>.assembler", "");
        m_params = node.second.get<std::string>("<xmlattr>.params", "");
        m_encoderKey = 0x4b;    // TODO: pass this in XML

        if(codeTemplatePath == "" || m_assembler == "")
            throw std::runtime_error(MODULE_NAME + " one or more attributes is empty in CodeTemplate node");

        m_codeTemplatePath = codeTemplatePath;
        if(!boost::filesystem::exists(m_codeTemplatePath))
        {
            std::stringstream errMsg;
            errMsg << MODULE_NAME + " file \"" << codeTemplatePath << "\" does not exist";
            throw std::runtime_error(errMsg.str());
        }

        codeTemplateFound = true;
        break;
    }

    if(!codeTemplateFound)
        throw std::runtime_error(MODULE_NAME + " no CodeTemplate node found in Engine node");
}

void EncryptionEngine::mutate(std::shared_ptr<PEFile> PE, std::map<std::string, std::string>& context)
{
    std::unique_ptr<TemplateAssembler> assembler(new TemplateAssembler(m_codeTemplatePath, m_assembler, m_params));
    assembler->assemble();
    std::vector<uint8_t> decoderCode = assembler->getUserCode();

    unsigned long entryPointRVA = PE->getNTHeaders()->OptionalHeader.AddressOfEntryPoint;
    unsigned long entryPointOffset = entryPointRVA - PE->getNTHeaders()->OptionalHeader.BaseOfCode;
    SHOW_HEX(entryPointRVA);
    SHOW_HEX(entryPointOffset);

    std::shared_ptr<PESection> codeSection = PE->getSections()[".text"];
    std::shared_ptr<std::vector<uint8_t>> code = codeSection->getData();
    size_t codeSectionSize = codeSection->getSize();
    size_t codeSize = codeSectionSize - entryPointOffset;

    // encode original code segment
    for(unsigned int i = entryPointOffset; i < codeSectionSize; ++i)
        code->at(i) ^= m_encoderKey;

    // insert decoder at the end of code segment
    code->insert(code->end(), decoderCode.begin(), decoderCode.end());

    // set new entry point address. Code execution should start at the beginning of inserted decoder
    PE->getNTHeaders()->OptionalHeader.AddressOfEntryPoint = entryPointRVA + codeSize;

    context["resize"] = std::to_string(decoderCode.size());
    context["resizeFrom"] = codeSection->getName();
}