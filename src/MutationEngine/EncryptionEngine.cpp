#include "EncryptionEngine.h"
#include "Utils\Debug\Debug.h"

#include <fstream>
#include <boost\filesystem.hpp>
#include <boost\assign\list_of.hpp>

static const std::string DECODER_KEY_WILDCARD  = "<DECODER_KEY>";
static const std::string CODE_SIZE_WILDCARD    = "<CODE_SIZE>";
static const std::string JUMP_OFFSET_WILDCARD  = "<JUMP_OFFSET>";

EncryptionEngine::EncryptionEngine(const boost::property_tree::ptree& engineTree)
    : IMutationEngine("EncryptionEngine")
    , IXMLParser("EncryptionEngine")
    , m_internalJumpSize(0)
    , m_jumpOffset("")
{
    validateSubtree(engineTree);

    for(const boost::property_tree::ptree::value_type& node : engineTree)
    {
        std::string nodeName = node.first.data();
        if(!findInRequiredSubnodes(nodeName))
            continue;

        if(nodeName == "Configuration")
            readConfiguration(node.second);
        else if(nodeName == "CodeProvider")
            readCodeProvider(node.second);
    }
}

void EncryptionEngine::mutate(std::shared_ptr<PEFile> PE, std::map<std::string, std::string>& context)
{
    if(m_isMultiple)
    {
        auto propertyIt = context.find("prevDecoderSize");
        if(propertyIt == context.end())
            throw std::runtime_error(MODULE_NAME + " multiple encryption engine does not inherit jumpOffset");

        std::string prevDecoderSizeStr = propertyIt->second;
        unsigned int prevDecoderSize = static_cast<unsigned int>(std::stoul(prevDecoderSizeStr.c_str(), 0, 16));
        m_jumpOffset = std::to_string(prevDecoderSize + m_internalJumpSize);
        context.erase(propertyIt);
    }

    unsigned long entryPointRVA = PE->getNTHeaders()->OptionalHeader.AddressOfEntryPoint;
    unsigned long entryPointOffset = entryPointRVA - PE->getNTHeaders()->OptionalHeader.BaseOfCode;

    std::shared_ptr<PESection> codeSection = PE->getSections()[".text"];
    std::shared_ptr<std::vector<uint8_t>> code = codeSection->getData();
    size_t codeSectionSize = codeSection->getVirtualSize();
    size_t codeSize = codeSectionSize - entryPointOffset;

    SHOW_HEX(entryPointRVA);
    SHOW_HEX(entryPointOffset);
    SHOW_HEX(codeSize);

    registerWildcards(codeSize);

    std::vector<uint8_t> decoderCode = m_codeProvider->getUserCode();

    // encode original code segment
    uint8_t encryptionKeyByte = static_cast<uint8_t>(std::stoul(m_encryptionKey.c_str(), 0, 16));
    for(unsigned int i = entryPointOffset; i < codeSectionSize; ++i)
        code->at(i) ^= encryptionKeyByte;

    // insert decoder at the end of code segment
    code->insert(code->end(), decoderCode.begin(), decoderCode.end());

    // update context in case other encryption modules will use it
    context["prevDecoderSize"] = std::to_string(decoderCode.size());

    // set new entry point address. Code execution should start at the beginning of inserted decoder
    PE->getNTHeaders()->OptionalHeader.AddressOfEntryPoint = entryPointRVA + codeSize;
    
    // make code segment writeable
    codeSection->getSectionHeader()->Characteristics |= IMAGE_SCN_MEM_WRITE;

    // indicate, that relocations may be broken, so we want Windows loader to load this PE only at preferred address
    PE->getNTHeaders()->FileHeader.Characteristics |= IMAGE_FILE_RELOCS_STRIPPED;
}

std::vector<std::string>& EncryptionEngine::getRequiredSubnodes()
{
    static std::vector<std::string> requiredSubnodes = boost::assign::list_of("Configuration")
                                                                             ("CodeProvider")
                                                                             ;
    return requiredSubnodes;
}

void EncryptionEngine::readConfiguration(const boost::property_tree::ptree& configurationTree)
{
    m_isMultiple = configurationTree.get<bool>("<xmlattr>.isMultiple", false);
    m_encryptionKey = configurationTree.get<std::string>("<xmlattr>.encryptionKey", "");
    if(m_isMultiple)
        m_internalJumpSize = configurationTree.get<unsigned int>("<xmlattr>.internalJumpSize", 0);
}

void EncryptionEngine::readCodeProvider(const boost::property_tree::ptree& codeProviderTree)
{
    m_codeProvider = ICodeProvider::create(codeProviderTree);
}

void EncryptionEngine::registerWildcards(size_t codeSize)
{
    std::stringstream codeSizeStr;
    codeSizeStr << "0x" << std::hex << codeSize;

    m_codeProvider->addWildcard(DECODER_KEY_WILDCARD, m_encryptionKey);
    m_codeProvider->addWildcard(CODE_SIZE_WILDCARD, codeSizeStr.str());

    if(m_isMultiple)
    {
        m_codeProvider->addWildcard(JUMP_OFFSET_WILDCARD, m_jumpOffset);
    }
}