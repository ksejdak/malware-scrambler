#include "EncryptionEngine.h"
#include "Utils\Assembler\TemplateAssembler.h"
#include "Utils\Debug\Debug.h"

#include <fstream>
#include <boost\filesystem.hpp>

static const std::string DECODER_KEY_WILDCARD = "<DECODER_KEY>";
static const std::string CODE_SIZE_WILDCARD   = "<CODE_SIZE>";

EncryptionEngine::EncryptionEngine(const boost::property_tree::ptree& engineTree)
    : IMutationEngine("EncryptionEngine")
{
    bool codeTemplateFound = false;
    for(const boost::property_tree::ptree::value_type& node : engineTree)
    {
        if(std::string(node.first.data()) != "CodeTemplate")
            continue;

        std::string codeTemplatePath = node.second.get<std::string>("<xmlattr>.path", "");
        std::string processedCodeTemplatePath = "processed_" + codeTemplatePath;
        m_assembler = node.second.get<std::string>("<xmlattr>.assembler", "");
        m_params = node.second.get<std::string>("<xmlattr>.params", "");
        m_decoderKey = node.second.get<std::string>("<xmlattr>.decoderKey", "");

        if(codeTemplatePath == "" || m_assembler == "" || m_decoderKey == "")
            throw std::runtime_error(MODULE_NAME + " one or more attributes is empty in CodeTemplate node");

        m_codeTemplatePath = codeTemplatePath;
        if(!boost::filesystem::exists(m_codeTemplatePath))
        {
            std::stringstream errMsg;
            errMsg << MODULE_NAME + " file \"" << codeTemplatePath << "\" does not exist";
            throw std::runtime_error(errMsg.str());
        }
        m_processedCodeTemplatePath = m_codeTemplatePath.parent_path();
        m_processedCodeTemplatePath /= "processedCodeTemplate.asm";

        codeTemplateFound = true;
        break;
    }

    if(!codeTemplateFound)
        throw std::runtime_error(MODULE_NAME + " no CodeTemplate node found in Engine node");
}

void EncryptionEngine::mutate(std::shared_ptr<PEFile> PE, std::map<std::string, std::string>& context)
{
    unsigned long entryPointRVA = PE->getNTHeaders()->OptionalHeader.AddressOfEntryPoint;
    unsigned long entryPointOffset = entryPointRVA - PE->getNTHeaders()->OptionalHeader.BaseOfCode;

    std::shared_ptr<PESection> codeSection = PE->getSections()[".text"];
    std::shared_ptr<std::vector<uint8_t>> code = codeSection->getData();
    size_t codeSectionSize = codeSection->getVirtualSize();
    size_t codeSize = codeSectionSize - entryPointOffset;

    // code template preprocessing
    bool keyWildcardFound = false;
    bool sizeWildcardFound = false;

    std::ifstream codeTemplateFile(m_codeTemplatePath.string());
    std::ofstream processedCodeTemplateFile(m_processedCodeTemplatePath.string());
    std::string line;
    while(std::getline(codeTemplateFile, line))
    {
        // replace decoder key wildcard
        size_t keyPos = line.find(DECODER_KEY_WILDCARD);
        if(keyPos != std::string::npos)
        {
            line.replace(keyPos, DECODER_KEY_WILDCARD.size(), m_decoderKey);
            keyWildcardFound = true;
        }

        // replace code size wildcard
        size_t sizePos = line.find(CODE_SIZE_WILDCARD);
        if(sizePos != std::string::npos)
        {
            std::stringstream codeSizeSS;
            codeSizeSS << "0x" << std::hex << codeSize;
            line.replace(sizePos, CODE_SIZE_WILDCARD.size(), codeSizeSS.str());
            sizeWildcardFound = true;
        }

        processedCodeTemplateFile << line << std::endl;
    }
    codeTemplateFile.close();
    processedCodeTemplateFile.close();

    if(!keyWildcardFound || ! sizeWildcardFound)
        throw std::runtime_error(MODULE_NAME + " code template doesn't contain [" + DECODER_KEY_WILDCARD + "] or [" + CODE_SIZE_WILDCARD + "] wildcard");

    std::unique_ptr<TemplateAssembler> assembler(new TemplateAssembler(m_processedCodeTemplatePath, m_assembler, m_params));
    assembler->assemble();
    std::vector<uint8_t> decoderCode = assembler->getUserCode();

    std::stringstream ss;
    ss << m_decoderKey;
    uint8_t decoderKey;
    ss >> decoderKey;

    // encode original code segment
    //for(unsigned int i = entryPointOffset; i < codeSectionSize; ++i)
    //    code->at(i) ^= decoderKey;

    // insert decoder at the end of code segment
    code->insert(code->end(), decoderCode.begin(), decoderCode.end());

    // set new entry point address. Code execution should start at the beginning of inserted decoder
    PE->getNTHeaders()->OptionalHeader.AddressOfEntryPoint = entryPointRVA + codeSize;
}