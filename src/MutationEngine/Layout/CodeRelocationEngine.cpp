#include "CodeRelocationEngine.h"
#include "PortableExecutable\PortableExecutableCommon\CodeSectionLayoutAnalyzer.h"
#include "Utils\Debug\Debug.h"
#include "Utils\CodeProvider\ICodeProvider.h"

#include <boost\assign\list_of.hpp>

CodeRelocationEngine::CodeRelocationEngine(const boost::property_tree::ptree& engineTree)
    : IMutationEngine("CodeRelocationEngine")
    , IXMLParser("CodeRelocationEngine")
{
    validateSubtree(engineTree);

    for(const boost::property_tree::ptree::value_type& node : engineTree)
    {
        std::string nodeName = node.first.data();
        if(!findInRequiredSubnodes(nodeName))
            continue;

        if(nodeName == "Configuration")
            readConfiguration(node.second);
    }
}

void CodeRelocationEngine::mutate(std::shared_ptr<PEFile> PE, std::map<std::string, std::string>& context)
{
    LOG_EMPTY();
    LOG_INFO("Starting mutation...");

    unsigned long sourceRVA = 0;
    size_t relocationSize = 0;
    computeRelocationOptions(sourceRVA, relocationSize, PE, context);

    // get source section
    std::shared_ptr<PESection> sourceSection = PE->RVAToSection(sourceRVA);
    std::shared_ptr<std::vector<uint8_t>> sourceSectionData = sourceSection->getData();
    size_t sourceOffset = sourceRVA - sourceSection->getSectionHeader()->VirtualAddress;

    // get destination section
    std::string lastSectionName = PE->getSectionsOrder().back();
    std::shared_ptr<PESection> destinationSection = PE->getSections()[lastSectionName];
    std::shared_ptr<std::vector<uint8_t>> destinationSectionData = destinationSection->getData();
    unsigned long destinationRVA = destinationSection->getSectionHeader()->VirtualAddress + (destinationSection->isShrinked() ? destinationSection->getVirtualSize() : destinationSection->getDataSize());

    // copy data from source to destination section
    destinationSectionData->insert(destinationSectionData->end(), sourceSectionData->begin() + sourceOffset, sourceSectionData->begin() + sourceOffset + relocationSize);
    sourceSection->getSectionHeader()->Characteristics |= IMAGE_SCN_MEM_WRITE;
    destinationSection->getSectionHeader()->Characteristics |= IMAGE_SCN_MEM_WRITE;

    // clear source data
    std::memset(sourceSectionData->data() + sourceOffset, 0, relocationSize);

    // update context for other engines
    if(m_sourceType == CODE_PROVIDERS)
    {
        context["movedCodeSize"] = std::to_string(relocationSize);
        context["movedCodeRVA"] = std::to_string(destinationRVA);
    }

    LOG_INFO("Mutation success!");
}

std::vector<std::string>& CodeRelocationEngine::getRequiredSubnodes()
{
    static std::vector<std::string> requiredSubnodes = boost::assign::list_of("Configuration")
                                                                             ;
    return requiredSubnodes;
}

void CodeRelocationEngine::readConfiguration(const boost::property_tree::ptree& configurationTree)
{
    m_id = configurationTree.get<std::string>("<xmlattr>.id", "");
    std::string source = configurationTree.get<std::string>("<xmlattr>.source", "");
    m_sourceType = (source == "context") ? CONTEXT : CODE_PROVIDERS;
}

void CodeRelocationEngine::computeRelocationOptions(unsigned long& sourceRVA, size_t& relocationSize, std::shared_ptr<PEFile> PE, std::map<std::string, std::string>& context)
{
    if(m_sourceType == CODE_PROVIDERS)
    {
        // compute relocationStartRVA
        unsigned long entryPointRVA = PE->getNTHeaders()->OptionalHeader.AddressOfEntryPoint;
        std::shared_ptr<PESection> codeSection = PE->RVAToSection(entryPointRVA);

        CodeSectionLayoutAnalyzer codeSectionLayoutAnalyzer;
        size_t codeBeginningOffset = codeSectionLayoutAnalyzer.checkCodeBeginningOffset(entryPointRVA, PE);
        sourceRVA = codeSection->getSectionHeader()->VirtualAddress + codeBeginningOffset;

        // compute movedCodeSize
        std::vector<const boost::property_tree::ptree>& registeredCodeProviders = ICodeProvider::getRegisteredCodeProviders();
        for(const boost::property_tree::ptree providerTree : registeredCodeProviders)
        {
            std::shared_ptr<ICodeProvider> codeProvider = ICodeProvider::create(providerTree, false);
            relocationSize += codeProvider->getUserCode(true).size();
        }
        registeredCodeProviders.clear();
    }
    else
    {
        // retrieve relocation source RVA
        auto relocationSourceRVAIt = context.find("relocationSourceRVA");
        if(relocationSourceRVAIt == context.end())
            throw std::runtime_error(MODULE_NAME + " copy relocation engine does not inherit relocationSourceRVA");

        std::string relocationSourceRVAStr = relocationSourceRVAIt->second;
        sourceRVA = std::stoul(relocationSourceRVAStr.c_str(), 0);
        context.erase(relocationSourceRVAIt);

        // retrieve relocation size
        auto relocationSizeIt = context.find("relocationSize");
        if(relocationSizeIt == context.end())
            throw std::runtime_error(MODULE_NAME + " copy relocation engine does not inherit relocationSize");

        std::string relocationSizeStr = relocationSizeIt->second;
        relocationSize = static_cast<size_t>(std::stoul(relocationSizeStr.c_str(), 0));
        context.erase(relocationSizeIt);
    }
}